<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS9之适配ATS | 刘春桂的博客</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS9之适配ATS</h1><a id="logo" href="/.">刘春桂的博客</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS9之适配ATS</h1><div class="post-meta">Oct 11, 2015<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2015/10/11/ios9zhi-gua-pei-ats/" href="/2015/10/11/ios9zhi-gua-pei-ats/#comments" class="ds-thread-count"></a><div class="post-content"><p>最近的iOS9系统出来了，而网络方面的ATS(App Transport Security)特性可以说每个人都要经历。而我这篇博客，就是结合我最近几天的经历，来谈谈从服务器到iOS客户端对ATS的适配。</p>
<h3 id="一、简单谈谈ATS-App-Transport-Security"><a href="#一、简单谈谈ATS-App-Transport-Security" class="headerlink" title="一、简单谈谈ATS(App Transport Security)"></a>一、简单谈谈ATS(App Transport Security)</h3><p>ATS(App Transport Security)是为了提高App与服务器之间安全传输数据一个特性，这个特性从iOS9和OSX10.11开始出现，它默认需要满足以下几个条件：</p>
<ul>
<li>服务器TLS版本至少是1.2版本</li>
<li>连接加密只允许几种先进的加密</li>
<li>证书必须使用SHA256或者更好的哈希算法进行签名，要么是2048位或者更长的RSA密钥，要么就是256位或更长的ECC密钥</li>
</ul>
<p>如果想了解哪几种先进的加密是被允许的，详情请见官方文档<a href="https://developer.apple.com/library/mac/technotes/App-Transport-Security-Technote/" target="_blank" rel="external">App Transport Security Technote</a></p>
<a id="more"></a>
<h3 id="二、搭建HTTPS服务器"><a href="#二、搭建HTTPS服务器" class="headerlink" title="二、搭建HTTPS服务器"></a>二、搭建HTTPS服务器</h3><p>搭建HTTPS服务器有两种方式，一种是创建证书请求，然后到权威机构认证，随之配置到服务器；另外一种是自建证书，然后配置给服务器。第一种方式搭建的HTTPS服务器当然是最优的了，建立网站的话，直接就会被信任，而作为移动端app的服务器时，也不需要为ATS做过多的适配。虽然说权威的机构认证都是需要钱的，但是如今也不乏存在免费的第三方认证机构；第二种方式搭建的HTTPS服务器，对于网站来说完全不可行，用户打开时直接弹出一个警告提醒，说这是一个不受信任的网站，让用户是否继续，体验很差，而且让用户感觉网站不安全。对于移动端来说，在iOS9出现之前，这个没什么问题，但是在iOS9出来之后，第二种方式是通不过ATS特性，需要将NSAllowsArbitraryLoads设置为YES才行。所以，我推荐使用第一种方式搭建HTTPS服务器。<br>下面，咱们来说说这两种方式都如何进行操作。</p>
<h5 id="第一种、使用CA机构认证的证书搭建HTTPS服务器"><a href="#第一种、使用CA机构认证的证书搭建HTTPS服务器" class="headerlink" title="第一种、使用CA机构认证的证书搭建HTTPS服务器"></a>第一种、使用CA机构认证的证书搭建HTTPS服务器</h5><p>1、创建证书请求，并提交给CA机构认证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#生成私钥</div><div class="line">openssl genrsa -des3 -out private.key 2048</div><div class="line">#生成服务器的私钥，去除密钥口令 </div><div class="line">openssl rsa -in private.key -out server.key</div><div class="line">#生成证书请求</div><div class="line">openssl req -new -key private.key -out server.csr</div></pre></td></tr></table></figure>
<p>将生成server.csr提交给CA机构，CA机构对它进行签名之后，然后会生成签名后的根证书和服务器证书发送给你，这个时候的证书就是CA认证之后的证书。我们这里将根证书和服务器证书分别改名为ca.crt和serve.crt。</p>
<p>2、配置Apache服务器<br>将ca.crt、server.key、server.crt上传到阿里云服务器，使用SSH登陆进入这三个文件的目录，执行下面命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir ssl</div><div class="line">cp server.crt /alidata/server/httpd/conf/ssl/server.crt</div><div class="line">cp server.key /alidata/server/httpd/conf/ssl/server.key</div><div class="line">cp demoCA/cacert.pem /alidata/server/httpd/conf/ssl/ca.crt</div><div class="line">cp -r ssl /alidata/server/httpd/conf/</div></pre></td></tr></table></figure>
<p>编辑<code>/alidata/server/httpd/conf/extra/httpd-ssl.conf</code>文件，找到SSLCertificateFile、SSLCertificateKeyFile、SSLCACertificatePath、SSLCACertificateFile进行修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 指定服务器证书位置</div><div class="line">SSLCertificateFile &quot;/alidata/server/httpd/conf/ssl/server.crt&quot;</div><div class="line"># 指定服务器证书key位置</div><div class="line">SSLCertificateKeyFile &quot;/alidata/server/httpd/conf/ssl/server.key&quot;</div><div class="line"># 证书目录</div><div class="line">SSLCACertificatePath &quot;/alidata/server/httpd/conf/ssl&quot;</div><div class="line"># 根证书位置</div><div class="line">SSLCACertificateFile &quot;/alidata/server/httpd/conf/ssl/ca.crt&quot;</div></pre></td></tr></table></figure>
<p>修改vhost配置<code>vim /alidata/server/httpd/conf/vhosts/phpwind.conf</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;VirtualHost *:443&gt;</div><div class="line">        SSLCertificateFile    /alidata/server/httpd/conf/ssl/server.crt</div><div class="line">        SSLCertificateKeyFile /alidata/server/httpd/conf/ssl/server.key</div><div class="line">        SSLCACertificatePath /alidata/server/httpd/conf/ssl</div><div class="line">        SSLCACertificateFile /alidata/server/httpd/conf/ssl/ca.crt</div><div class="line">        ServerName www.casetree.cn</div><div class="line">        DocumentRoot /alidata/www</div><div class="line">&lt;/VirtualHost&gt;</div></pre></td></tr></table></figure>
<p>最后，重启Apache服务器，在浏览器输入网址查看是否配置成功。我这里是个人使用，申请的是免费的证书，我申请证书的网站是<a href="https://buy.wosign.com" target="_blank" rel="external">沃通</a>。<br>搭建的成果：<a href="https://www.casetree.cn" target="_blank" rel="external">https://www.casetree.cn</a></p>
<h5 id="第二种、自建证书配置HTTPS服务器"><a href="#第二种、自建证书配置HTTPS服务器" class="headerlink" title="第二种、自建证书配置HTTPS服务器"></a>第二种、自建证书配置HTTPS服务器</h5><p>请查看我的上一篇<a href="http://www.liuchungui.com/blog/2015/09/25/zi-jian-zheng-shu-pei-zhi-httpsfu-wu-qi/">自建证书配置HTTPS服务器</a></p>
<h3 id="三、使用nscurl对服务器进行检测"><a href="#三、使用nscurl对服务器进行检测" class="headerlink" title="三、使用nscurl对服务器进行检测"></a>三、使用nscurl对服务器进行检测</h3><p>搭建完HTTPS服务器之后，可以使用nscurl命令来进行检测，查看建立的HTTPS服务器是否能通过ATS特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nscurl --ats-diagnostics --verbose https://casetree.cn</div></pre></td></tr></table></figure>
<p>如果HTTPS服务器能通过ATS特性，则上面所有测试案例都是PASS；如果某一项的Reuslt是FAIL，就找到ATS Dictionary来查看，就能知道HTTPS服务器不满足ATS哪个条件。<br>这里我前面碰到一个问题，就是自建证书的时候，通过此命令进行测试时，发现Result全是FAIL，而且在iOS的代码测试中也出现了一个很奇怪的现象，就是相同的代码，在iOS8.4请求数据完全正常，但是在iOS9上，直接是连接失败。最终发现，其实就是因为自建证书不受信任，是通不过ATS的，除非将NSAllowsArbitraryLoads设置为YES。</p>
<h3 id="四、iOS客户端"><a href="#四、iOS客户端" class="headerlink" title="四、iOS客户端"></a>四、iOS客户端</h3><p>在上面的第二大步骤当中，HTTPS服务器满足ATS默认的条件，而且SSL证书是通过权威的CA机构认证过的，那么我们在使用Xcode7开发的时候，对网络的适配什么都不用做，我们也能正常与服务器通信。但是，当我们对安全性有更高的要求时或者我们自建证书时，我们需要本地导入证书来进行验证。<br>那么，如何本地导入证书进行验证呢？<br>在这里先提一下，由于iOS客户端支持的证书是DER格式的，我们需要创建客户端证书。创建客户端证书，直接将服务端的CA根证书导出成DER格式就行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl  x509  -inform PEM  -outform DER -in ca.crt -out ca.cer</div></pre></td></tr></table></figure>
<p>导入完证书之后，我们分别来说说使用NSURLSession和AFNetworking来进行本地验证。</p>
<h5 id="首先，来说说使用NSURLSession验证"><a href="#首先，来说说使用NSURLSession验证" class="headerlink" title="首先，来说说使用NSURLSession验证"></a>首先，来说说使用NSURLSession验证</h5><p>验证步骤如下：<br>1、导入CA根证书到工程中，即我们创建的ca.cer<br>2、获取trust object，通过SecCertificateCreateWithData方法读取导入的证书的数据生成一个证书对象，然后通过SecTrustSetAnchorCertificates<br>设置这个证书为trust object的信任根证书（trusted anchor)<br>3、通过SecTrustEvaluate方法去验证trust object<br>下面是主要OC实现代码，Demo工程我也放在github上了，有OC和Swift两种语言，下载Demo请点击<a href="https://github.com/liuchungui/HTTPSConnectDemo" target="_blank" rel="external">HTTPSConnectDemo</a>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//导入客户端证书</span></div><div class="line">    <span class="built_in">NSString</span> *cerPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"ca"</span> ofType:<span class="string">@"cer"</span>];</div><div class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:cerPath];</div><div class="line">    SecCertificateRef certificate = SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>) data);</div><div class="line">    <span class="keyword">self</span>.trustedCerArr = @[(__bridge_transfer <span class="keyword">id</span>)certificate];</div><div class="line">    </div><div class="line">    <span class="comment">//发送请求</span></div><div class="line">    <span class="built_in">NSURL</span> *testURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://casetree.cn/web/test/demo.php"</span>];</div><div class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</div><div class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:testURL]];</div><div class="line">    [task resume];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSURLSessionDelegate</span></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</div><div class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> * __<span class="keyword">nullable</span> credential))completionHandler&#123;</div><div class="line">    </div><div class="line">    OSStatus err;</div><div class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</div><div class="line">    SecTrustResultType  trustResult = kSecTrustResultInvalid;</div><div class="line">    <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//获取服务器的trust object</span></div><div class="line">    SecTrustRef serverTrust = challenge.protectionSpace.serverTrust;</div><div class="line">    </div><div class="line">    <span class="comment">//将读取的证书设置为serverTrust的根证书</span></div><div class="line">    err = SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)<span class="keyword">self</span>.trustedCerArr);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(err == noErr)&#123;</div><div class="line">        <span class="comment">//通过本地导入的证书来验证服务器的证书是否可信，如果将SecTrustSetAnchorCertificatesOnly设置为NO，则只要通过本地或者系统证书链任何一方认证就行</span></div><div class="line">        err = SecTrustEvaluate(serverTrust, &amp;trustResult);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (err == errSecSuccess &amp;&amp; (trustResult == kSecTrustResultProceed || trustResult == kSecTrustResultUnspecified))&#123;</div><div class="line">        <span class="comment">//认证成功，则创建一个凭证返回给服务器</span></div><div class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</div><div class="line">        credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:serverTrust];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//回调凭证，传递给服务器</span></div><div class="line">    <span class="keyword">if</span>(completionHandler)&#123;</div><div class="line">        completionHandler(disposition, credential);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：<br>1、SecTrustSetAnchorCertificates方法会设置一个标示去屏蔽trust object对其它根证书的信任；如果你也想信任系统默认的根证书，请调用SecTrustSetAnchorCertificatesOnly方法，清空这个标示（设置为NO）<br>2、验证的方法不仅仅只有这一种，更多的验证方法，请参考<a href="https://developer.apple.com/library/ios/technotes/tn2232/_index.html#//apple_ref/doc/uid/DTS40012884-CH1-SECCUSTOMIZEAPIS" target="_blank" rel="external">HTTPS Server Trust Evaluation</a></p>
<h5 id="下面，来谈谈AFNetworking是如何验证的，我们如何使用AFNetworking"><a href="#下面，来谈谈AFNetworking是如何验证的，我们如何使用AFNetworking" class="headerlink" title="下面，来谈谈AFNetworking是如何验证的，我们如何使用AFNetworking"></a>下面，来谈谈AFNetworking是如何验证的，我们如何使用AFNetworking</h5><p>AFNetworking的证书验证工作是由AFSecurityPolicy来完成的，所以这里我们主要来了解一下AFSecurityPolicy。<strong>注意：我这里使用的是AFNetworking2.6.0，它跟2.5.0是有区别的。</strong><br>说到AFSecurityPolicy，我们必须要提到它三个重要的属性，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (readonly, nonatomic, assign) AFSSLPinningMode SSLPinningMode;</div><div class="line">@property (nonatomic, assign) BOOL allowInvalidCertificates;</div><div class="line">@property (nonatomic, assign) BOOL validatesDomainName;</div></pre></td></tr></table></figure>
<p>SSLPingMode是最重要的属性，它标明了AFSecurityPolicy是以何种方式来验证。它是一个枚举类型，这个枚举类型有三个值，分别是AFSSLPinningModeNone、AFSSLPinningModePublicKey、AFSSLPinningModeCertificate。其中，AFSSLPinningModeNone代表了AFSecurityPolicy不做更严格的验证，只要是系统信任的证书就可以通过验证，不过，它受到allowInvalidCertificates和validatesDomainName的影响；AFSSLPinningModePublicKey是通过比较证书当中公钥(PublicKey)部分来进行验证，通过SecTrustCopyPublicKey方法获取本地证书和服务器证书，然后进行比较，如果有一个相同，则通过验证，此方式主要适用于自建证书搭建的HTTPS服务器和需要较高安全要求的验证；AFSSLPinningModeCertificate则是直接将本地的证书设置为信任的根证书，然后来进行判断，并且比较本地证书的内容和服务器证书内容是否相同，来进行二次判断，此方式适用于较高安全要求的验证。<br>allowInvalidCertificates属性代表是否允许不信任的证书通过验证，默认为NO<br>validatesDomainName属性代表是否验证主机名，默认为YES</p>
<p>接下来，我们说下验证流程。验证流程主要放在AFSecurityPolicy的- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain方法当中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust</div><div class="line">                  forDomain:(NSString *)domain</div><div class="line">&#123;</div><div class="line">    //当使用自建证书验证域名时，需要使用AFSSLPinningModePublicKey或者AFSSLPinningModeCertificate</div><div class="line">    if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123;</div><div class="line">        NSLog(@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;);</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableArray *policies = [NSMutableArray array];</div><div class="line">    //需要验证域名时，需要添加一个验证域名的策略</div><div class="line">    if (self.validatesDomainName) &#123;</div><div class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];</div><div class="line">    &#125; else &#123;</div><div class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //设置验证的策略，可以是多个</div><div class="line">    SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);</div><div class="line"></div><div class="line">    //SSLPinningMode为AFSSLPinningModeNone时，allowInvalidCertificates为YES，则代表服务器任何证书都能验证通过；如果它为NO，则需要判断此服务器证书是否是系统信任的证书</div><div class="line">    if (self.SSLPinningMode == AFSSLPinningModeNone) &#123;</div><div class="line">        if (self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust))&#123;</div><div class="line">            return YES;</div><div class="line">        &#125; else &#123;</div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //获取服务器证书的内容</div><div class="line">    NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</div><div class="line">    switch (self.SSLPinningMode) &#123;</div><div class="line">        case AFSSLPinningModeNone:</div><div class="line">        default:</div><div class="line">            return NO;</div><div class="line">        case AFSSLPinningModeCertificate: &#123;</div><div class="line">            //AFSSLPinningModeCertificate是直接将本地的证书设置为信任的根证书，然后来进行判断，并且比较本地证书的内容和服务器证书内容是否相同，如果有一个相同则返回YES</div><div class="line">            </div><div class="line">            NSMutableArray *pinnedCertificates = [NSMutableArray array];</div><div class="line">            for (NSData *certificateData in self.pinnedCertificates) &#123;</div><div class="line">                [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];</div><div class="line">            &#125;</div><div class="line">            //设置本地的证书为根证书</div><div class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</div><div class="line">            </div><div class="line">            //通过本地的证书来判断服务器证书是否可信，不可信，则验证不通过</div><div class="line">            if (!AFServerTrustIsValid(serverTrust)) &#123;</div><div class="line">                return NO;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            //判断本地证书和服务器证书的内容是否相同</div><div class="line">            NSUInteger trustedCertificateCount = 0;</div><div class="line">            for (NSData *trustChainCertificate in serverCertificates) &#123;</div><div class="line">                if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123;</div><div class="line">                    trustedCertificateCount++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return trustedCertificateCount &gt; 0;</div><div class="line">        &#125;</div><div class="line">        case AFSSLPinningModePublicKey: &#123;</div><div class="line">            //AFSSLPinningModePublicKey是通过比较证书当中公钥(PublicKey)部分来进行验证，通过SecTrustCopyPublicKey方法获取本地证书和服务器证书，然后进行比较，如果有一个相同，则通过验证</div><div class="line">            </div><div class="line">            NSUInteger trustedPublicKeyCount = 0;</div><div class="line">            NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</div><div class="line">            </div><div class="line">            //判断服务器证书的公钥与本地的证书公钥是否相同，相同则客户端认证通过</div><div class="line">            for (id trustChainPublicKey in publicKeys) &#123;</div><div class="line">                for (id pinnedPublicKey in self.pinnedPublicKeys) &#123;</div><div class="line">                    if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</div><div class="line">                        trustedPublicKeyCount += 1;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return trustedPublicKeyCount &gt; 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说了验证流程，我们最后来看看AFNetworking怎么使用，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> _httpClient = [[BGAFHTTPClient alloc] initWithBaseURL:[NSURL URLWithString:baseURL]];</div><div class="line"> AFSecurityPolicy *policy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</div><div class="line"> //是否允许CA不信任的证书通过</div><div class="line">policy.allowInvalidCertificates = YES;</div><div class="line">//是否验证主机名</div><div class="line">policy.validatesDomainName = YES;</div><div class="line">_httpClient.securityPolicy = policy;</div></pre></td></tr></table></figure>
<p> 这里我就没有建立Demo了，如果要看的话，可以看看我写的一个框架<a href="https://github.com/liuchungui/BGNetwork" target="_blank" rel="external">BGNetwork</a>，里面的Demo对ATS进行了适配，AFNetworking的使用放在BGNetworkConnector类里面的<code>- (instancetype)initWithBaseURL:(NSString *)baseURL delegate:(id&lt;BGNetworkConnectorDelegate&gt;)delegate</code>初始化方法中。</p>
<h3 id="五、适配ATS"><a href="#五、适配ATS" class="headerlink" title="五、适配ATS"></a>五、适配ATS</h3><p>前面的内容讲述都是满足ATS特性的情况，但若是服务器是自建证书搭建的，或者TLS版本是1.0的话，服务器又不能轻易改动，那么我们客户端如何适配呢？<br>不急，我们可以在工程中的Info.plist文件当中进行设置，主要参照下图：<br><img src="http://ww3.sinaimg.cn/large/91c6e389jw1ewvshzy5ilj21340m641y.jpg" alt="图片"><br>适配过程中的一些总结：<br>1、如果是自建证书，没有经过权威机构认证的证书，那么需要将NSAllowsArbitraryLoads设置为YES才能通过。NSAllowsArbitraryLoads为YES，以前的HTTP请求也能通过。<br>2、如果是认证过的证书，那么可以通过<code>nscurl --ats-diagnostics --verbose https://casetree.cn</code>这样的命令来查看服务器支持的ATS Dictionary，然后进行对应的设置。</p>
<p>适配的部分，也可以参照<a href="https://github.com/ChenYilong/iOS9AdaptationTips#1-demo1_ios9%E7%BD%91%E7%BB%9C%E9%80%82%E9%85%8D_ats%E6%94%B9%E7%94%A8%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84https" target="_blank" rel="external">Demo1_iOS9网络适配_ATS：改用更安全的HTTPS</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回顾前面的内容，总结一下，主要讲了一下几点内容    </p>
<ol>
<li>ATS需要满足的条件    </li>
<li>如何建立证书，搭建HTTPS服务器      </li>
<li>使用nscurl命令来检测HTTPS服务器是否满足ATS特性    </li>
<li>客户端的适配，讲述了NSURLSession和AFNetworking的使用    </li>
<li>讲述了如果建立的服务器不满足ATS的条件时，我们如何适配    </li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.apple.com/library/mac/technotes/App-Transport-Security-Technote/" target="_blank" rel="external">App Transport Security Technote</a><br><a href="https://developer.apple.com/library/ios/technotes/tn2232/_index.html#//apple_ref/doc/uid/DTS40012884-CH1-SECCUSTOMIZEAPIS" target="_blank" rel="external">HTTPS Server Trust Evaluation</a><br><a href="http://www.cocoachina.com/ios/20150810/12947.html" target="_blank" rel="external">打造安全的App！iOS安全系列之 HTTPS</a><br><a href="http://www.cocoachina.com/ios/20140916/9632.html" target="_blank" rel="external">AFNetworking源码解析&lt;三&gt;</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://www.liuchungui.com/2015/10/11/ios9zhi-gua-pei-ats/" data-id="civ4lyl6700044jfypdmrkspc" class="article-share-link">分享到</a><div class="tags"><a href="/tags/iOS9/">iOS9</a><a href="/tags/HTTPS/">HTTPS</a><a href="/tags/ATS/">ATS</a><a href="/tags/CA证书/">CA证书</a><a href="/tags/openssl/">openssl</a><a href="/tags/nscurl/">nscurl</a></div><div class="post-nav"><a href="/2015/10/19/cocoapodschuang-jian-si-you-pods/" class="pre">CocoaPods创建私有Pods</a><a href="/2015/09/25/zi-jian-zheng-shu-pei-zhi-httpsfu-wu-qi/" class="next">自建证书配置HTTPS服务器</a></div><div data-thread-key="2015/10/11/ios9zhi-gua-pei-ats/" data-title="iOS9之适配ATS" data-url="http://www.liuchungui.com/2015/10/11/ios9zhi-gua-pei-ats/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2015/10/11/ios9zhi-gua-pei-ats/" data-title="iOS9之适配ATS" data-url="http://www.liuchungui.com/2015/10/11/ios9zhi-gua-pei-ats/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.liuchungui.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Gitbook/">Gitbook</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/">ReactNative</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/angular/">angular</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/octopress/">octopress</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/年度总结/">年度总结</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/22/bootstrap-datetimepicker集成到angular使用/">angular中使用时间控件bootstrap-datetimepicker</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/03/angular-入门之常用指令使用/">Angular1.5 入门之常用指令使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/09/搭建Hexo博客/">搭建Hexo博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/01/wei-xin-gong-zhong-hao-kai-fa-zong-jie/">微信公众号开发总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/10/mac10-dot-11sheng-ji-an-zhuang-openssl/">Mac10.11升级安装openssl</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/08/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-androidpian/">ReactNative之原生模块开发并发布——android篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/02/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-iospian/">ReactNative之原生模块开发并发布——iOS篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/23/ubuntuxia-da-jian-vpn/">ubuntu下搭建vpn历程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/04/gcdzong-jie/">GCD总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/04/reactnativezhi-flexbu-ju-zong-jie/">ReactNative之Flex布局总结</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">刘春桂的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'liuchungui'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?40391c9d11f57c2384e5811d517bef62";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>