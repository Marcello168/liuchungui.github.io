
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>liuchungui's Blog</title>
  <meta name="author" content="刘春桂">

  
  <meta name="description" content="GCD的知识点： queue分成两种，分别是串行队列(Serial Dispatch Queue)和并行队列（Concurrent Dispatch Queue)。
串行队列只会创建一个线程，而各个串行队列之间是并行的。
串行队列个数创建不受限制，也就是通过串行队列创建的线程可以有很多个， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.liuchungui.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="liuchungui's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<script type="text/javascript">
  function addBlankTargetForLinks () {
      $('a[href^="http"]').each(function(){
          $(this).attr('target', '_blank');
      });
  }
  $(document).bind('DOMNodeInserted', function(event) {
      addBlankTargetForLinks();
  });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">liuchungui's Blog</a></h1>
  
    <h2>代码嗨起来</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="www.liuchungui.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/04/04/gcdzong-jie/">GCD总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-04-04T19:13:33+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>7:13 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>GCD的知识点：</h3>

<ol>
<li>queue分成两种，分别是串行队列(Serial Dispatch Queue)和并行队列（Concurrent Dispatch Queue)。</li>
<li>串行队列只会创建一个线程，而各个串行队列之间是并行的。</li>
<li>串行队列个数创建不受限制，也就是通过串行队列创建的线程可以有很多个，但是这样会存在消耗大量内存的问题；而并行队列不会，不管创建多少个并行队列，XNU内核只使用有效管理的线程。</li>
<li>在iOS6以后，ARC已经实现了GCD的内存管理，所以不用我们去管理它的内存了。</li>
<li>系统已经为我们提供了两个queue，分别是main queue和global queue，其中main queue是串行队列，global queue是并行队列。</li>
</ol>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/04/04/gcdzong-jie/">更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/04/04/reactnativezhi-flexbu-ju-zong-jie/">ReactNative之Flex布局总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-04-04T18:35:53+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:35 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>从二月份开始学习ReactNative到现在已经有两个月了，零碎的记录了很多笔记，一直想写一些ReactNative相关的东西，奈何感觉自己学习的还比较浅陋，而且笔记比较杂乱，不知从何而起，所以迟迟没有动笔。清明三天假，决定无论如何都得整一篇出来。本来是想整一篇ReactNative布局篇的，但是看看那么多布局属性，自己对CSS又不是特别熟悉，布局篇从何谈起？所以，专门拿出ReactNative中布局比较重要的一个点Flex布局来做下总结，算是开启ReactNative篇章。</p>

<p>Flex是Flexible Box的缩写，意为“弹性布局”，2009年它由W3C提出了一种新的网页布局方案。而FaceBook将这个布局也应用到React和ReactNative两个项目当中。而在ReactNative当中，网页的有些属性和属性的值并不支持，下面来看看ReactNative当中支持的属性。（如果对于Flex布局不太了解的同学，可以看看<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a>）</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/04/04/reactnativezhi-flexbu-ju-zong-jie/">更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/03/14/runtimezhi-lei-yu-dui-xiang-zong-jie/">Runtime之类与对象总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-14T23:30:27+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>11:30 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>以前在使用<a href="https://github.com/elado/jastor">jastor</a>解析Json成model的时候里面涉及到了Runtime里面的知识，所以专门看了<a href="http://blog.jobbole.com/79566/">Objective-C Runtime 运行时之一到六</a>这一系列的文章，整个Jastor也就懂了，现在非常出名的框架<a href="https://github.com/Mantle/Mantle">Mantle</a>，<a href="https://github.com/icanzilb/JSONModel">JSONModel</a>也都是差不多的原理。但是，一年之后的今天重新再看的时候，发现大概思路知道，但是具体的一些细节实现需要写的时候，却一时上不了手，所以重新看了<a href="http://blog.jobbole.com/79566/">Objective-C Runtime 运行时</a>一系列，然后整理了一下，细节部分附上一些代码，方便以后查找。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/03/14/runtimezhi-lei-yu-dui-xiang-zong-jie/">更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/03/04/bgsession/">BGSession一个基于NSUserDefaults实现的轻量级本地数据存储</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-04T16:35:38+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>4:35 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://github.com/liuchungui/BGSession">BGSession</a>是一个基于NSUserDefaults实现的轻量级数据存储，你只需要简单的继承它，给它添加属性，设置属性的值，就能通过NSUserDefaults同步到本地。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/03/04/bgsession/">更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/01/2015nian-zong-jie/">2015年总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-01T01:22:29+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>1:22 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>现在已经2016年1点了，去年这个时候看到别人都纷纷写着一年的总结，那个时候顿生崇拜。今年，我也来个简短的总结吧！</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/01/01/2015nian-zong-jie/">更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/26/gitbookan-zhuang-shi-yong/">Gitbook安装使用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-26T17:15:07+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:15 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>GitBook 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书。</p></blockquote>

<p>在这篇博客中，记录了一下gitbook的安装使用，更详细的使用请查看下面内容：
gitbook详细使用文档：<a href="help.gitbook.com">help.gitbook.com</a>      <br/>
gitbook官网:<a href="https://www.gitbook.com">https://www.gitbook.com</a>  <br/>
github地址:<a href="https://github.com/GitbookIO/gitbook">https://github.com/GitbookIO/gitbook</a></p>

<h3>1、安装</h3>

<p>首先到<a href="http://nodejs.cn/">nodejs</a>下载，安装Node.js的包管理器npm。
然后，通过<code>sudo npm install -g gitbook-cli</code>命令安装gitbook</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/12/26/gitbookan-zhuang-shi-yong/">更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/24/uicollectionviewdong-hua/">UICollectionView动画</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-24T00:00:26+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>一、简单使用</h2>

<p>UICollectionView更新事件有四种分别是<code>插入</code>、<code>删除</code>、<code>刷新</code>、<code>移动</code>，
api使用起来和UITableView类似，具体可以自己在代码中找，如果需要执行多个更新事件，可以放到performBatchUpdates中的updates闭包中作为一组动画，然后全部执行完之后通过completion调回。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">collectionView</span><span class="p">.</span><span class="n">performBatchUpdates</span><span class="p">({</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Void</span> <span class="k">in</span>
</span><span class='line'>            <span class="n">collectionView</span><span class="p">.</span><span class="n">insertItemsAtIndexPaths</span><span class="p">(</span><span class="n">insertIndexPaths</span><span class="p">)</span>
</span><span class='line'>            <span class="n">collectionView</span><span class="p">.</span><span class="n">moveItemAtIndexPath</span><span class="p">(</span><span class="n">currentIndexPath</span><span class="p">,</span> <span class="nl">toIndexPath</span><span class="p">:</span> <span class="n">toIndexPath</span><span class="p">)</span>
</span><span class='line'>            <span class="p">},</span> <span class="nl">completion</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">isFinish</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Void</span> <span class="k">in</span>
</span><span class='line'>        <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<h2>二、UICollectionView动画</h2>

<p>四种不同的更新事件，系统默认会带有动画，不过是比较简单的。我们可以自定义layout或者继承flowLayout，在内部实现我们自己想要的动画。下面，我们来说说动画的流程，以及系统默认的四种动画内部是如何的，并且通过代码来修改达到自己想要的动画。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/24/uicollectionviewdong-hua/">更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/06/uicollectionviewzhi-zi-ding-yi-layout/">UICollectionView之自定义Layout</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-06T00:00:26+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>当我们使用系统自带的UICollectionViewFlowLayout无法实现我们的布局时，我们就可以考虑自定义layout。     <br/>
所以，了解并学习一下自定义Layout是很有必要。    <br/>
其实可以分三个步骤：</p>

<ol>
<li>覆写prepareLayout方法，并在里面事先就计算好必要的布局信息并存储起来。</li>
<li>基于prepareLayout方法中的布局信息，使用collectionViewContentSize方法返回UICollectionView的内容尺寸。</li>
<li>使用layoutAttributesForElementsInRect:方法返回指定区域cell、Supplementary View和Decoration View的布局属性。</li>
</ol>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/06/uicollectionviewzhi-zi-ding-yi-layout/">更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/02/uicollectionviewzhi-jie-shao-shi-yong-pian/">UICollectionView之介绍使用篇</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-02T00:29:12+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>12:29 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>实现垂直方向的单列表来说，使用UITableView足以；若是需要构建横向滑动列表、gridView等直线型布局，则使用UICollectionView+UICollectionViewFlowLayout搭建最合适；更复杂的布局，则可以使用UICollectionView+自定义Layout来实现。</p>

<p>而这篇博客就来介绍一下UICollectionView。</p>

<p>首先，来了解一下UICollectionView工作流程：</p>

<p><img src="http://ww3.sinaimg.cn/large/7746cd07jw1exjnjqrju5j20x00qk76h.jpg" alt="" /></p>

<p>当UICollectionView显示内容时，先从数据源获取cell，然后交给UICollectionView。再从UICollectionViewLayout获取对应的layout attributes(布局属性)。最后，根据每个cell对应的layout attributes(布局属性)来对cell进行布局，生成了最终的界面。而用户交互的时候，都是通过Delegate来进行交互。当然，上面只是布局cell，但是UICollectionView内部还有Supplementary View和Decoration View，也可以对其进行布局。</p>

<p>上面，我们了解了UICollectionView的工作流程，我们将UICollectionView分成视图、数据源和代理方法、UICollectionViewLayout三块来介绍。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/02/uicollectionviewzhi-jie-shao-shi-yong-pian/">更多 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/23/gitzong-jie/">Git简单总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-10-23T14:45:46+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>2:45 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这篇文章分为两部分，一是搭建git服务器，二是git命令，主要是记录了一下我搭建git服务器流程和用到的相关命令。</p>

<h2>一、Mac环境下搭建Git服务器</h2>

<p>这里简单说一下Mac环境下通过git+ssh搭建服务器的流程。</p>

<h4>1、打开远程登陆</h4>

<p>系统偏好设置 -> 共享 -> 远程登陆</p>

<h4>2、添加git用户</h4>

<p>这一步不加上也可以，但是为了更好的管理和安全着想，最好加上一个git用户   <br/>
系统偏好设置 -> 用户与群组 -> 添加名为git的用户</p>

<h4>3、初始化一个空仓库</h4>

<p>在git用户目录下创建一个repos文件夹专门用来管理仓库</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir repos
</span><span class='line'>$ cd repos
</span><span class='line'># 初始化一个空仓库
</span><span class='line'>$ git init --bare test.git</span></code></pre></td></tr></table></div></figure>


<h4>4、添加密钥</h4>

<p>在git服务端添加客户端的公钥后，以后git访问不需要密码了，下面是客户端与服务端的操作。    <br/>
客户端：   <br/>
使用<code>ssh-keygen</code>命令生成密钥，执行完后会生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，其中<code>id_rsa</code>是私钥，<code>id_rsa.pub</code>是公钥。客户端将<code>id_rsa.pub</code>文件交给git服务端就行了。       <br/>
服务端：       <br/>
将客户端的<code>id_rsa.pub</code>中的内容放到<code>/Users/git/.ssh/authorized_keys</code>文件中。主要，客户端每个公钥占用独立的一行，有时复制会出现问题，可以使用<code>cat id_rsa.pub &gt;&gt; /Users/git/.ssh/authorized_keys</code>命令。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/10/23/gitzong-jie/">更多 &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/04/04/gcdzong-jie/">GCD总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/04/reactnativezhi-flexbu-ju-zong-jie/">ReactNative之Flex布局总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/14/runtimezhi-lei-yu-dui-xiang-zong-jie/">Runtime之类与对象总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/04/bgsession/">BGSession一个基于NSUserDefaults实现的轻量级本地数据存储</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/01/2015nian-zong-jie/">2015年总结</a>
      </li>
    
  </ul>
</section>
<section>
 <h1>Categories</h1>
 <ul id="categories">
  <li class='category'><a href='/blog/categories/git/'>git (1)</a></li>
<li class='category'><a href='/blog/categories/gitbook/'>gitbook (1)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (9)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (1)</a></li>
<li class='category'><a href='/blog/categories/reactnative/'>reactnative (1)</a></li>
<li class='category'><a href='/blog/categories/web/'>web (2)</a></li>
<li class='category'><a href='/blog/categories/年度总结/'>年度总结 (1)</a></li>

 </ul>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?40391c9d11f57c2384e5811d517bef62";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<p>
  &copy; 2016 - 刘春桂 -
  <span class="credit">基于 <a href="http://octopress.org" target="_blank">Octopress</a></span>
  <span class="credit">, 感谢 <a href="http://gitcafe.com/signup?invited_by=tangqiaoboy" target="_blank">GitCafe</a> 为本站提供存储空间</span>
</p>
</footer>
  











</body>
</html>
