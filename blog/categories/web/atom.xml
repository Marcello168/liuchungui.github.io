<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Web | liuchungui's Blog]]></title>
  <link href="http://www.liuchungui.com/blog/categories/web/atom.xml" rel="self"/>
  <link href="http://www.liuchungui.com/"/>
  <updated>2016-03-04T17:09:42+08:00</updated>
  <id>http://www.liuchungui.com/</id>
  <author>
    <name><![CDATA[刘春桂]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mac环境下Nginx实现反向代理]]></title>
    <link href="http://www.liuchungui.com/blog/2015/10/21/mhuan-jing-xia-nginxshi-xian-fan-xiang-dai-li/"/>
    <updated>2015-10-21T10:16:01+08:00</updated>
    <id>http://www.liuchungui.com/blog/2015/10/21/mhuan-jing-xia-nginxshi-xian-fan-xiang-dai-li</id>
    <content type="html"><![CDATA[<h2>1、安装</h2>

<p>首先，我们需要搭建Nginx环境，我这里是通过homebrew一键式搭建，步骤如下：  <br/>
1、安装homebrew</p>

<pre><code>$ ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></pre>

<p>以<a href="brew.sh">官网homebrew</a>为准</p>

<p>2、安装nginx</p>

<pre><code>$ brew install nginx
</code></pre>

<p>查看Nginx安装的版本
<code>
$ nginx -v
</code></p>

<p>Nginx常用的命令有</p>

<pre><code class="">#查看版本，以及配置文件地址
nginx -V
#查看版本 
nginx -v
#指定配置文件
nginx -c filename
#帮助
nginx -h
#重新加载配置|重启|停止|退出 nginx
nginx -s reload|reopen|stop|quit
#打开 nginx
sudo nginx
#测试配置是否有语法错误
sudo nginx -t
</code></pre>

<!-- more -->


<h2>2、Nginx配置WEB服务器</h2>

<p>使用Nginx做反向代理，我们需要了解一下Nginx中http模块的配置。</p>

<h4>编辑Nginx配置文件</h4>

<pre><code>$ sudo vim /usr/local/etc/nginx/nginx.conf
</code></pre>

<p>找到http模块，修改http模块中的listen为80，如下：</p>

<pre><code>http {
    #导入类型配置文件
    include       mime.types;
    #设定默认类型为二进制流
    default_type  application/octet-stream;
    #启用sendfile()函数
    sendfile        on;
    #客户端与服务器连接的超时时间为65秒，超过65秒，服务器关闭连接
    keepalive_timeout  65;
    #是否开启gzip，默认关闭
    #gzip  on;
    #一个server块
    server {
        #服务器监听的端口为80
        listen       80;
        #服务器名称为localhost，我们可以通过localhost来访问这个server块的服务
        server_name  localhost;
        #location块，它存放在server块当中，location会尝试根据用户请求中的URI来匹配上面的/uri表达式，如果可以匹配，就选择location {}块中的配置来处理用户请求。
        location / {
            #以root方式设置资源路径，它与alias的不同请见下面的 http模块中文件路径定义
            root   html;
            #默认访问的页面，从左依次找到右，直到找到这个文件，然后返回结束请求
            index  index.html index.htm;
            #设置错误页面，对应的错误码是404，错误页面是/Users/user/Sites/404.html
            error_page 404  /404.html;
        }
    }
    include servers/*;
}
</code></pre>

<h4>http模块中文件路径定义：</h4>

<p>1、以<strong>root</strong>方式设置资源路径  <br/>
语法: root path;  <br/>
默认: root html;  <br/>
配置块: http, server, location, if   <br/>
例如，定义资源文件相对于HTTP请求的根目录。</p>

<pre><code>location /download/ {
    root /opt/web/html;
}
</code></pre>

<p>在上面的配置中，如果有一个请求的URI是/download/index/test.html，那么Web服务器将会返回服务器上/opt/web/html/download/index/test.html文件的内容。</p>

<p>2、以<strong>alias</strong>方式设置资源路径   <br/>
语法：alias path;   <br/>
配置块：location     <br/>
alias也是用来设置文件资源路径的，它与root的不同点主要在于如何解读紧跟location后面的uri参数，这将会致使alias与root以不同的方式将用户请求映射到真正的磁盘文件上。  <br/>
例如，如果有一个请求的URI是/conf/nginx.conf，而用户实际想访问的文件在/usr/local/nginx/conf/nginx.conf，那么想要使用alias来进行设置的话，可以采用如下方式：</p>

<pre><code>location /conf {
    alias /usr/local/nginx/conf/;
}
</code></pre>

<p>如果用root设置，那么语句如下所示：</p>

<pre><code>location /conf {
    alias /usr/local/nginx/;
}
</code></pre>

<p>使用alias时，在URI向实际文件路径的映射过程中，已经把location后配置的/conf这部分字符串丢弃掉，因此，/conf/nginx.conf请求将根据alias path映射为path/nginx.conf。root则不然，它会根据完整的URI请求来映射，因此/conf/nginx.conf请求会根据root path映射为path/conf/nginx.conf。这也是root可以放置到http、server、location或if块中，而alias只能放置到location块中的原因。  <br/>
alias后面还可以添加正则表达式，例如：</p>

<pre><code>location ~ ^/test/(\w+)\.(\w+)$ {
    alias /usr/local/nginx/$2/$1.$2;
}
</code></pre>

<p>这样，请求在访问/test/nginx.conf时，Nginx会返回/usr/local/nginx/conf/nginx.conf文件中的内容。</p>

<h4>开启Nginx的Web服务</h4>

<p>开启Nginx服务之前，如果我们开启了Apache服务，那么我需要先关闭Apache服务</p>

<pre><code>#开启Nginx
$ sudo nginx
</code></pre>

<p>使用localhost来访问，若是出现nginx欢迎页，说明成功。</p>

<h2>3、使用Nginx做反向代理</h2>

<p>反向代理（reverse proxy）方式是指用代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络中的上游服务器，并将从上游服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外的表现就是一个Web服务器。   <br/>
这里，我是在本机搭建，通过修改host来模拟多个域名访问本机的nginx。</p>

<h4>1、修改hosts文件</h4>

<p>$ vim /etc/hosts    <br/>
在内部添加域名解析</p>

<pre><code>127.0.0.1 pinger.com www.pinger.com
127.0.0.1 test.com www.test.com
127.0.0.1 chungui.com www.chungui.com
</code></pre>

<h4>2、修改nginx配置文件</h4>

<p>$ sudo vim /usr/local/etc/nginx/nginx.conf    <br/>
在后面添加server模块，内部通过<code>proxy_pass</code>设置反向代理</p>

<pre><code>    server {
        listen  80;
        server_name  *.pinger.com pinger.com;
        location / {
            proxy_pass http://www.baidu.com;
        }
    }
    server {
        listen 80;
        server_name *.chungui.com chungui.com;
        location / {
            proxy_pass http://www.renren.com;
        }
    }
    server {
        listen 80;
        server_name test.com;
        location / {
            proxy_pass http://www.zhihu.com;
        }
    } 
</code></pre>

<p>其中，server_name可以指向多个域名值</p>

<h4>3、重启nginx服务</h4>

<pre><code>#重启服务
$ sudo nginx -s reload
</code></pre>

<p>这时，反向代理已经搭建成功。你可以在本地通过<code>chungui.com</code>访问到人人网，<code>test.com</code>访问到知乎。不过，设置<code>pinger.com</code>访问的<code>http://www.baidu.com</code>站点，而百度服务器内部会自动跳转到<code>https://www.baidu.com</code>站点，所以我们通过<code>pinger.com</code>会跳转到<code>https://www.baidu.com</code>，这个时候我们可以将百度的替换成https就行了，修改配置如下：</p>

<pre><code>server {
    listen       80;
    server_name  *.pinger.com pinger.com;
    location / {
        proxy_pass https://www.baidu.com;
    }
}
</code></pre>

<p>这个时候，再使用<code>pinger.com</code>在浏览器里访问时就不会出现跳转的问题了。</p>

<h2>参考</h2>

<p><a href="http://manual.51yip.com/nginx/">Nginx中文参考手册,教程</a>    <br/>
<a href="http://blog.csdn.net/dracotianlong/article/details/21817097">mac 安装 nginx 环境</a>   <br/>
<a href="http://segmentfault.com/a/1190000002963355">Mac OS使用brew安装Nginx、MySQL、PHP-FPM的LAMP开发环境</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自建证书配置HTTPS服务器]]></title>
    <link href="http://www.liuchungui.com/blog/2015/09/25/zi-jian-zheng-shu-pei-zhi-httpsfu-wu-qi/"/>
    <updated>2015-09-25T11:24:02+08:00</updated>
    <id>http://www.liuchungui.com/blog/2015/09/25/zi-jian-zheng-shu-pei-zhi-httpsfu-wu-qi</id>
    <content type="html"><![CDATA[<h3>说明</h3>

<p>1、写这篇博客的初衷是因为最近iOS9出来了，苹果官方默认要求使用HTTPS，所以自己想整一个HTTPS服务器，也想好好了解一下HTTPS通信，也知道了HTTPS其实就是在HTTP的基础上加上了SSL/TLS。具体想了解SSL/TLS原理的请浏览<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a>和<a href="http://segmentfault.com/a/1190000002554673">SSL/TLS原理详解</a>。中途看了很多博客，也花了不少时间，所以想记录一些东西。</p>

<p>2、这篇博客的内容主要是讲升级openssl、如何自己创建证书、配置证书到服务器和自建CA。其中对证书不太了解的，可以看<a href="http://kb.cnblogs.com/page/194742/">数字证书及CA的扫盲介绍</a>这篇文章。本篇博客其中第2步和第3步已经重复，只需要选择其中一步操作就可以搭建HTTPS服务器，当然搭建都是不受信任的，如果是架设网站还是需要到权威的CA机构申请证书。本来还有生成iOS客户端的证书和使用证书连接服务器相关的内容，由于篇幅的原因就把它放在下一篇吧。</p>

<p>3、本人使用了Mac10.10.5和Ubuntu 14.04.1进行配置搭建，本篇博客主要以Unbuntu 14.04.1系统为主。而本人这个Ubuntu 14.04.1是阿里云一键安装的，而且没有更改里面的服务器设置，所以诸多的配置可能与一般Linux系统不太相同（与我电脑上的Linux mint就很大不同）。不过，我会在最后说明一下Mac和Linux配置一些不同的地方，其实都是一些相关路径的不同。当然，有可能你的Apache安装路径与我说的几种路径都不同，没关系，对照着修改也应该没什么问题。</p>

<!-- more -->


<h3>1、安装升级openssl</h3>

<h5>首先，查看下当前设备的openssl版本，如果版本在openssl1.0.1g以上，请略过</h5>

<pre><code>openssl version -a
#OpenSSL 1.0.1f 6 Jan 2014
</code></pre>

<p>如果是处于<code>1.0.1-1.0.1f</code>的版本，那就赶快升级到<code>1.0.1g</code>版本以上吧！因为这些版本存在漏洞，详情请见<a href="http://drops.wooyun.org/papers/1381">关于OpenSSL“心脏出血”漏洞的分析</a></p>

<p>从上面信息可以看出我们的系统版本是1.0.1f，openssl需要升级，那我们先来下载源代码</p>

<pre><code>wget http://www.openssl.org/source/openssl-1.0.1g.tar.gz     
</code></pre>

<p>下载完之后，解压并进行安装</p>

<pre><code>tar -zxvf openssl-1.0.1g.tar.gz         
cd  openssl-1.0.1g         
./config shared zlib            
make &amp;&amp; make install          
</code></pre>

<p>安装的过程中，碰到了一个问题
make: *** [install_docs] Error 255
解决这个问题请使用<code>make install_sw</code>安装，详情见<a href="https://github.com/openssl/openssl/issues/57">https://github.com/openssl/openssl/issues/57</a></p>

<h5>随后，进行相关的设置</h5>

<pre><code>#修改历史的OpenSSL文件设置备份
mv /usr/bin/openssl /usr/bin/openssl.old
mv /usr/include/openssl /usr/include/openssl.old

#设置软连接使其使用新的OpenSSL版本 刚刚安装的OpenSSL默认安装在/usr/local/ssl
ln -s /usr/local/ssl/bin/openssl /usr/bin/openssl
ln -s /usr/local/ssl/include/openssl /usr/include/openssl

#更新动态链接库数据
echo "/usr/local/ssl/lib" &gt;&gt; /etc/ld.so.conf
ldconfig -v
</code></pre>

<p>最后查看一下版本</p>

<pre><code>openssl version
OpenSSL 1.0.1g 7 Apr 2014
</code></pre>

<p>1.0.1g版本安装成功</p>

<h3>2、创建用私钥签名的证书，配置到Apache服务器</h3>

<h5>首先，生成私钥，创建请求证书，使用私钥对证书进行签名</h5>

<p>生成私钥  <br/>
<code>openssl genrsa -des3 -out private.key 2048</code> <br/>
-des3代表加上了加密，后面的2048是代表生成的密钥的位数，1024已经不是很安全，详情请见<a href="http://get.jobdeer.com/1607.get">互联网全站HTTPS的时代已经到来</a></p>

<p>生成证书请求   <br/>
<code>openssl req -new -key private.key -out server.csr</code>  <br/>
这一步需要填写一些信息，其中<code>Common Name (e.g. server FQDN or YOUR name) []</code>这个需要填写你的域名或服务器地址。</p>

<p>生成服务器的私钥，去除密钥口令   <br/>
<code>openssl rsa -in private.key -out server.key</code></p>

<p>使用私钥为证书请求签名，生成给服务器签署的证书，格式是x509的PEM格式  <br/>
<code>openssl x509 -req -in server.csr -out server.crt -outform pem -signkey server.key -days 3650</code> <br/>
-outform pem指定证书生成的格式，默认是pem，所以这个命令也可以写作成<code>sudo openssl x509 -req -in server.csr -out server.crt -signkey server.key -days 3650</code>。</p>

<p>将证书copy到Apache配置路径下</p>

<pre><code>sudo  mkdir /alidata/server/httpd/conf/ssl
cp server.key /alidata/server/httpd/conf/ssl/server.key
cp server.crt  /alidata/server/httpd/conf/ssl/server.crt
</code></pre>

<h5>其次，配置Apache服务器</h5>

<p>编辑/alidata/server/httpd/conf/httpd.conf文件</p>

<pre><code>#LoadModule ssl_module modules/mod_ssl.so
#LoadModule socache_shmcb_module modules/mod_socache_shmcb.so
#Include conf/extra/httpd-ssl.conf
</code></pre>

<p>将这三行前面的#去掉</p>

<p>编辑<code>/alidata/server/httpd/conf/extra/httpd-ssl.conf</code>文件，找到SSLCertificateFile、SSLCertificateKeyFile，修改它们两对应的文件</p>

<pre><code>SSLCertificateFile "/alidata/server/httpd/conf/ssl/server.crt"
SSLCertificateKeyFile "/alidata/server/httpd/conf/ssl/server.key"
</code></pre>

<p>编辑<code>/alidata/server/httpd/conf/vhosts/phpwind.conf</code>文件，这里我没有更改阿里云的配置，如果你不是阿里云服务器，找到对应的<code>httpd/conf/extra/httpd-vhosts.conf</code>文件进行修改。这个文件我主要加了下面的内容：</p>

<pre><code>&lt;VirtualHost *:443&gt;
        SSLCertificateFile    /alidata/server/httpd/conf/ssl/server.crt
        SSLCertificateKeyFile /alidata/server/httpd/conf/ssl/server.key
        ServerName 182.92.5.161
        DocumentRoot /alidata/www
&lt;/VirtualHost&gt;
</code></pre>

<p>最后，咱们重启Apache服务器，输入链接查看是否配置成功。</p>

<h3>3、自建CA，用CA证书进行签名，配置到Apache服务器</h3>

<h5>第一步、使用CA.sh创建CA根证书</h5>

<p>修改openssl的配置文件<code>sudo vim /usr/local/ssl/openssl.cnf</code>，修改<code>default_bits=1024</code>为<code>default_bits=2048</code>，使其openssl加密使用2048位，原因前面已经说过。</p>

<p>随后创建一个目录，并且将生成CA证书的脚本CA.sh复制到这个目录</p>

<pre><code>mkdir ca
cd ca
cp /usr/local/ssl/misc/CA.sh CA.sh
</code></pre>

<p>CA.sh这个脚本如果找不到，可以使用 <code>openssl version -a</code>查看openssl对应的目录，而CA.sh一般就在这个目录的子目录misc目录下。</p>

<p>之后执行<code>./CA.sh -newca</code>命令  <br/>
CA.sh会使用<code>/usr/local/ssl/openssl.cnf</code>中的配置来创建私钥和证书，这正是我们第一步为啥需要修改这个文件的原因。</p>

<p>创建CA证书过程中，不输入信息，直接回车，填写加密私钥的密码和生成CA证书的相关信息。</p>

<p>创建完之后会生成demoCA目录。这个目录有</p>

<pre><code>cacert.pem  certs  index.txt       index.txt.old  private
careq.pem   crl    index.txt.attr  newcerts       serial
</code></pre>

<p>其中cacert.pem是CA的证书，private存放CA的私钥，newcerts存放CA签名的备份。到这里，我们的CA已经建好了，下面我们可以通过CA来对我们的证书进行签名了。</p>

<h5>第二步、使用CA根证书为服务器证书签名</h5>

<pre><code>#生成私钥
sudo  openssl genrsa -des3 -out private.key 2048
#生成证书请求
sudo openssl req -new -key private.key -out server.csr
#生成服务器的私钥，去除密钥口令
sudo openssl rsa -in private.key -out server.key
#使用CA进行签名，生成server.crt
cp server.csr newreq.pem
./CA.sh -sign
mv newcert.pem server.crt
或者上面三步都不需要，直接使用下面一步
openssl ca -in server.csr -out server.crt
</code></pre>

<p>更多openssl ca 命令请见<a href="http://blog.csdn.net/as3luyuan123/article/details/13346613">OpenSSL命令&ndash;ca</a></p>

<h5>第三步、配置服务器：</h5>

<pre><code>mkdir ssl
cp server.crt ssl/server.crt
cp server.key ssl/server.key
cp demoCA/cacert.pem ssl/ca.crt
cp -r ssl /alidata/server/httpd/conf/
</code></pre>

<p>编辑<code>/alidata/server/httpd/conf/extra/httpd-ssl.conf</code>文件，找到SSLCertificateFile、SSLCertificateKeyFile、SSLCACertificatePath、SSLCACertificateFile进行修改</p>

<pre><code># 指定服务器证书位置
SSLCertificateFile "/alidata/server/httpd/conf/ssl/server.crt"
# 指定服务器证书key位置
SSLCertificateKeyFile "/alidata/server/httpd/conf/ssl/server.key"
# 证书目录
SSLCACertificatePath "/alidata/server/httpd/conf/ssl"
# 根证书位置
SSLCACertificateFile "/alidata/server/httpd/conf/ssl/ca.crt"
</code></pre>

<p>修改vhost配置<code>vim /alidata/server/httpd/conf/vhosts/phpwind.conf</code></p>

<pre><code>&lt;VirtualHost *:443&gt;
        SSLCertificateFile    /alidata/server/httpd/conf/ssl/server.crt
        SSLCertificateKeyFile /alidata/server/httpd/conf/ssl/server.key
        SSLCACertificatePath /alidata/server/httpd/conf/ssl
        SSLCACertificateFile /alidata/server/httpd/conf/ssl/ca.crt
        ServerName 182.92.5.161
        DocumentRoot /alidata/www
&lt;/VirtualHost&gt;
</code></pre>

<p>最后，咱们重启Apache服务器，在浏览器输入链接查看是否配置成功。可以在浏览器上查看证书信息，与第二步不同之处在于此时的证书有两个。</p>

<h3>最后，与Mac和寻常Linux系统一些区别</h3>

<h5>一、与MAC的几点不同</h5>

<p>1、首先安装openssl，因为本人还没有升级Mac系统上的openssl，所以暂时留着，以后升级了补上。  <br/>
2、Mac上对应的Openssl的路径是<code>/System/Library/OpenSSL/</code>  <br/>
3、Mac上对应的Apache的路径是<code>/etc/apache2/</code>  <br/>
4、Mac上重启服务器使用<code>/usr/sbin/apachectl restart</code>，阿里云服务器使用<code>/etc/init.d/httpd restart</code>或者<code>service httpd restart</code>   <br/>
5、Mac上vhost配置的路径是<code>/etc/apache2/extra/httpd-vhosts.conf</code></p>

<h5>二、与寻常Linux系统的不同</h5>

<p>主要借鉴<a href="http://m.blog.csdn.net/blog/whyliu_/41749521">MacOS openssl下生成建立CA并生成服务器和客户端证书方法</a>这篇文章   <br/>
1、linux上Apache的路径是<code>/usr/local/apache</code>  <br/>
2、linux上vhost配置的路径是<code>/usr/local/apache/conf/extra/httpd_vhosts.conf</code></p>

<h3>总结</h3>

<p>1、对HTTPS的理解  <br/>
它的基本原理是服务器拥有一个私钥，客户端拥有公钥，当然它们是使用证书管理的。每次通信它们通过证书进行身份认证。身份认证之后客户端发送一个“对话密钥”给服务器。传输“对话密钥”时，客户端公钥通过不对称加密算法进行加密了的，只有服务器才能解密。然后双方使用这个"对话密钥"对内容进行对称加密，双方之间传输内容。</p>

<p>2、对openssl、SSL/TLS的相关理解  <br/>
openssl是一套工具，它是一个开源库，可以对相关内容进行加密和解密，也可以生成证书并且进行数字签名。它创建的x509证书有PEM和DER两种编码，而且它们还可以导出p12文件。它使用的加密算法有对称加密，也有不对称加密。</p>

<p>3、HTTPS相关理论知识博客，值得细读  <br/>
<a href="http://segmentfault.com/a/1190000002568019">OpenSSL 与 SSL 数字证书概念贴</a>  <br/>
<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a>  <br/>
<a href="http://segmentfault.com/a/1190000002554673">SSL/TLS原理详解</a></p>

<h3>参考：</h3>

<p><a href="http://www.yezhongqi.com/archives/1377.html">https介绍与环境搭建</a>  <br/>
<a href="http://myswirl.blog.163.com/blog/static/5131864220071014102353799/">OpenSSL常用命令</a>  <br/>
<a href="http://blog.csdn.net/as3luyuan123/article/details/13344757">OpenSSL命令&mdash;CA.pl</a>  <br/>
<a href="http://m.blog.csdn.net/blog/whyliu_/41749521">MacOS openssl下生成建立CA并生成服务器和客户端证书方法</a>   <br/>
<a href="http://blog.csdn.net/zhu410289616/article/details/46566073">mac中apache开启https功能，本地发布安装app</a>  <br/>
<a href="http://www.cnblogs.com/kyrios/p/tls-and-certificates.html">TLS/HTTPS 证书生成与验证</a>   <br/>
<a href="http://www.cnblogs.com/phpinfo/archive/2013/08/09/3246376.html">OpenSSL小结</a>      <br/>
<a href="http://www.cnblogs.com/alittlebitcool/archive/2011/09/22/2185418.html">利用openssl进行RSA加密解密</a>  <br/>
<a href="http://blog.sina.com.cn/s/blog_a9303fd90101jmtx.html">DER 和 PEM 格式</a></p>
]]></content>
  </entry>
  
</feed>
