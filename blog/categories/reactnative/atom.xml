<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Reactnative | liuchungui's Blog]]></title>
  <link href="http://www.liuchungui.com/blog/categories/reactnative/atom.xml" rel="self"/>
  <link href="http://www.liuchungui.com/"/>
  <updated>2016-05-08T16:12:05+08:00</updated>
  <id>http://www.liuchungui.com/</id>
  <author>
    <name><![CDATA[刘春桂]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ReactNative之原生模块开发并发布——android篇]]></title>
    <link href="http://www.liuchungui.com/blog/2016/05/08/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-androidpian/"/>
    <updated>2016-05-08T14:00:09+08:00</updated>
    <id>http://www.liuchungui.com/blog/2016/05/08/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-androidpian</id>
    <content type="html"><![CDATA[<p>前段时间做了个ReactNative的App，发现ReactNative中不少组件并不存在，所以还是需要自己对原生模块进行编写让JS调用，正是因为在这个编写过程中遇到不少问题，发觉了官网文档中许多的不足。所以产生了写一个实践教程的想法，最终有了这么一篇文章。</p>

<p>整篇文章主要以编写一个原生模块为例子，来讲述了我们在编写原生模块所用到的一些知识，并且在整个例子中，配有了完整的实践代码，方便大家理解并调试。除了这些内容，文章还讲述了我们如何将自己编写的原生模块发布到npm上分享给别人使用。希望能够给大家带来帮助，也希望大家将自己编写的原生模块分享出来。</p>

<p>示例代码github地址：<a href="https://github.com/liuchungui/react-native-BGNativeModuleExample">https://github.com/liuchungui/react-native-BGNativeModuleExample</a></p>

<!-- more -->


<h2>准备工作</h2>

<p>我们需要先创建一个ReactNative工程，使用如下命令创建。</p>

<pre><code class="sh">$ react native init TestProject
</code></pre>

<p>创建好工程之后，我们使用android studio打开<code>TestProject/android/</code>下的android工程。</p>

<p>之后，点击android studio菜单上的File ——> New ——> New Module，之后选择<code>Android Library</code>，设置模块名和包名，我的设置如下：
<img src="http://ww2.sinaimg.cn/large/7746cd07jw1f3ilkyhcuzj21kw10w42q.jpg" alt="" /></p>

<p>点击完成之后，我们的安卓项目中就多了个名字为<code>nativemoduleexample</code>模块。
<img src="http://ww1.sinaimg.cn/large/7746cd07jw1f3iluj6owuj20qy11mgt8.jpg" alt="" />
之后，我们在<code>app</code>工程中的<code>build.gradle</code>文件中的<code>dependencies</code>添加一行<code>compile project(':nativemoduleexample')</code>，让主工程<code>app</code>依赖我们新创建的Library。</p>

<p>最后，我们还需要让新创建的Library依赖<code>react native</code>，和上面差不多，只需要在我们新创建的<code>nativemoduleexample</code>下的<code>build.gradle</code>中的<code>dependencies</code>添加一行<code>compile "com.facebook.react:react-native:+"</code>就行了。</p>

<h2>编写原生模块代码</h2>

<h4>1、创建原生模块，并进行注册</h4>

<p>我们首先点击打开前面创建的<code>nativemoduleexample</code>库，在<code>src/main/java/com/liuchungui/nativemoduleexample</code>目录下创建我们的原生模块类。当然，如果我们前面创建Library的包名不太一样，那<code>src/main/java/</code>后面跟上就是前面设置的包名。</p>

<p>在这个目录下，我们首先创建一个原生模块<code>BGNativeExampleModule</code>，它继承于<code>ReactContextBaseJavaModule</code>。这个原生模块必须实现两个方法，一个是覆写<code>getName</code>方法，它返回一个字符串名字，在JS中我们就使用这个名字调用这个模块；另外一个是构造方法<code>BGNativeExampleModule</code>。</p>

<pre><code class="java">package com.liuchungui.nativemoduleexample;

import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;

import java.lang.String;

public class BGNativeExampleModule extends ReactContextBaseJavaModule {
    public BGNativeExampleModule(ReactApplicationContext reactContext) {
        super(reactContext);
    }
    @Override
    public String getName() {
        return "BGNativeModuleExample";
    }
}
</code></pre>

<p>其中需要注意的是，模块名前的RCT前缀会被自动移除。例如"RCTBGNativeModuleExample"，在JS中的模块名字仍然是BGNativeModuleExample。</p>

<p>到这一步的时候，是不是就可以访问这个模块了？事实是现在还不能访问，因为我们还需要注册这个模块。</p>

<p>为了注册原生模块，我们首先创建一个<code>BGNativeExamplePackage</code>类，这个类要求实现<code>ReactPackage</code>接口，这个接口有三个方法<code>createNativeModules</code>、<code>createJSModules</code>和<code>createViewManagers</code>。其中，<code>createNativeModules</code>是用来添加原生模块的；<code>createViewManagers</code>是用来添加原生的UI组件；<code>createJSModules</code>暂时没用过，但是看官方的注释，应该是注册我们原生模块中用到的JS模块。</p>

<p>我们这里只需要在<code>createNativeModules</code>方法中添加原生模块，其他两个方法返回空数组就行了，整个package类的代码如下：</p>

<pre><code>package com.liuchungui.nativemoduleexample;

import com.facebook.react.ReactPackage;
import com.facebook.react.bridge.JavaScriptModule;
import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.uimanager.ViewManager;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class BGNativeExamplePackage implements ReactPackage {
    @Override
    public List&lt;NativeModule&gt; createNativeModules(ReactApplicationContext reactContext) {
        return Arrays.asList(new NativeModule[]{
                new BGNativeExampleModule(reactContext),
        });
    }
    public List&lt;Class&lt;? extends JavaScriptModule&gt;&gt; createJSModules() {
        return Collections.emptyList();
    }
    @Override
    public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) {
        return Collections.emptyList();
    }
}
</code></pre>

<p>最后，这个package需要在<code>MainActivity.java</code>文件中的<code>getPackages</code>方法中提供。这个文件位于我们的reactNative应用文件夹的android目录中，路径是:<code>android/app/src/main/java/com/testproject/MainActivity.java</code>。</p>

<pre><code>@Override
protected List&lt;ReactPackage&gt; getPackages() {
    return Arrays.&lt;ReactPackage&gt;asList(
        new MainReactPackage(),
            new BGNativeExamplePackage()
    );
}
</code></pre>

<p>到这个时候，我们终于可以在js中访问我们的原生模块了</p>

<pre><code>import { NativeModules } from 'react-native';
var BGNativeModuleExample = NativeModules.BGNativeModuleExample;
console.log(BGNativeModuleExample);
</code></pre>

<h4>2、为原生模块添加方法</h4>

<p>要导出一个方法给JS使用，Java方法需要使用注解<code>@ReactMethod</code>。方法的返回类型必须为void。ReactNative跨语言访问是异步进行的，所以想要给JS返回一个值，唯一的办法是使用回调函数或者发送事件。</p>

<pre><code>import com.facebook.react.bridge.ReactMethod;

@ReactMethod
public void testPrint(String name, ReadableMap info) {
    Log.i(TAG, name);
    Log.i(TAG, info.toString());
}
</code></pre>

<p>在JS中，我们如下调用这个方法：</p>

<pre><code>BGNativeModuleExample.testPrint("Jack", {
    height: '1.78m',
    weight: '7kg'
});
</code></pre>

<h4>3、参数类型</h4>

<p>在编写原生模块的时候，我们还需要知道原生Java数据类型和JS数据类型的映射关系：</p>

<pre><code>Boolean -&gt; Bool
Integer -&gt; Number
Double -&gt; Number
Float -&gt; Number
String -&gt; String
Callback -&gt; function
ReadableMap -&gt; Object
ReadableArray -&gt; Array
</code></pre>

<p>详情参考：<a href="https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/bridge/ReadableMap.java">ReadableMap</a>和<a href="https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/bridge/ReadableArray.java">ReadableArray</a></p>

<h4>4、回调函数</h4>

<p>原生模块还支持一种特殊的参数——回调函数。它提供了一个函数来把返回值传回给JS。</p>

<pre><code>import com.facebook.react.bridge.Callback;

@ReactMethod
public void getNativeClass(Callback callback) {
      callback.invoke("BGNativeExampleModule");
}
</code></pre>

<p>在JS中，我们可以通过以下方式获取到原生模块的类名：</p>

<pre><code class="javascript">BGNativeModuleExample.getNativeClass(name =&gt; {
  console.log("nativeClass: ", name);
});
</code></pre>

<h4>5、Promises</h4>

<blockquote><p>原生模块还可以使用promise来简化代码，搭配ES2016(ES7)标准的async/await语法则效果更佳。如果桥接原生方法的最后一个参数是一个Promise，则对应的JS方法就会返回一个Promise对象。</p></blockquote>

<pre><code class="java">import com.facebook.react.bridge.Promise;
@ReactMethod
public void testPromises(Boolean isResolve, Promise promise) {
    if(isResolve) {
        promise.resolve(isResolve.toString());
    }
    else {
        promise.reject(isResolve.toString());
    }
}
</code></pre>

<p>JS中如下调用</p>

<pre><code class="javascript">BGNativeModuleExample.testPromises(true)
.then(result =&gt; {
    console.log("result is ", result);
})
.catch(result =&gt; {
    console.log("result = ", result);
});
</code></pre>

<h4>6、导出常量</h4>

<p>  我们在<code>getContants</code>方法中导出js所需要使用的常量。</p>

<pre><code class="java">@Override
public  Map&lt;String, Object&gt; getConstants() {
    final Map&lt;String, Object&gt; constants = new HashMap&lt;&gt;();
    constants.put("BGModuleName", "BGNativeModuleExample");
    constants.put(TestEventName, TestEventName);
    return constants;
}
</code></pre>

<p> 我们在JS中打印<code>BGModuleName</code>这个常量的值：</p>

<pre><code class="javascript"> console.log("BGModuleName const value = ", BGNativeModuleExample.BGModuleName);
</code></pre>

<h4>7、给JS发送事件</h4>

<blockquote><p>原生模块可以在没有被调用的情况下往JS发送事件通知，最简单的办法是通过<code>RCTDeviceEventEmitter</code>，这可以通过<code>ReactContext</code>获得对应的引用。</p></blockquote>

<p>在这里，我们为了能够接收到事件，开启了一个定时器，每一秒发送一次事件：</p>

<pre><code class="java">public class BGNativeExampleModule extends ReactContextBaseJavaModule {
    protected static final String TAG = BGNativeExampleModule.class.getSimpleName();
    private static final  String TestEventName = "TestEventName";
    private Timer timer;
    public BGNativeExampleModule(final ReactApplicationContext reactContext) {
        super(reactContext);
        //开启定时器
        TimerTask task = new TimerTask() {
            @Override
            public void run() {
                //发送事件
                WritableMap params = Arguments.createMap();
                params.putString("name", "Jack");
                reactContext
                        .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
                        .emit(TestEventName, params);

            }
        };
        timer = new Timer();
        timer.schedule(task, 1000, 1000);
    }
}
</code></pre>

<p>在JS中，我们这里直接使用<code>DeviceEventEmitter</code>模块来监听事件。</p>

<pre><code class="javascript">//接收事件
DeviceEventEmitter.addListener(BGNativeModuleExample.TestEventName, info =&gt; {
  console.log(info);
});
</code></pre>

<p>官方文档中，说也可以使用<code>Subscribable mixin</code>的addListenerOn方法来接收事件，其实它就是对<code>DeviceEventEmitter</code>一种封装。而且，在<code>es6</code>之后，不再支持<code>mixins</code>，所以我们直接使用DeviceEventEmitter接收事件比较好。</p>

<h4>8、生命周期</h4>

<p>有时候，为了某些目的，我们需要监听ReactNative应用的生命周期。我们可以让原生模块实现<code>LifecycleEventListener</code>接口，然后使用<code>addLifecycleEventListener</code>注册一下监听。</p>

<pre><code class="java">public BGNativeExampleModule(final ReactApplicationContext reactContext) {
    super(reactContext);
    //添加监听
    reactContext.addLifecycleEventListener(this);
}
</code></pre>

<p>实现<code>LifecycleEventListener</code>接口</p>

<pre><code class="javascript">    @Override
    public void onHostResume() {
        Log.i(TAG, "onHostResume");
    }

    @Override
    public void onHostPause() {
        Log.i(TAG, "onHostPause");
        timer.cancel();
    }

    @Override
    public void onHostDestroy() {
        Log.i(TAG, "onHostDestroy");
        timer.cancel();
    }
</code></pre>

<p>这样，我们就可以监听ReactNative应用的生命周期了。</p>

<p>上面原生代码就编写好了，主要以代码实践为主，弥补官方文档中的一些不足，如果要需要了解更多的原生模块封装的知识，可以参考<a href="http://reactnative.cn/docs/0.22/native-modules-ios.html#content">原生模块</a>，也可以参考官方的源代码。</p>

<h2>二、发布上线</h2>

<h4>建立一个github仓库</h4>

<p>在github上创建一个仓库<code>react-native-BGNativeModuleExample</code>，克隆到本地，并且创建一个<code>android</code>文件夹。</p>

<pre><code class="sh">$ git clone https://github.com/liuchungui/react-native-BGNativeModuleExample.git
$ cd react-native-BGNativeModuleExample
$ mkdir android
</code></pre>

<h4>将Library复制到android文件夹下</h4>

<p>我们首先进入前面创建的<code>nativemoduleexample</code>这个Library下，然后将这个文件目录下所有文件copy到<code>react-native-BGNativeModuleExample/android</code>目录下。</p>

<pre><code>$ cp -R android/nativemoduleexample/* ~/github/react-native-BGNativeModuleExample/android
</code></pre>

<h4>发布到npm</h4>

<p>这里请参考我前面写的<a href="http://www.liuchungui.com/blog/2016/05/02/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-iospian/">ReactNative之原生模块开发并发布——iOS篇</a>中的<code>发布到npm</code>那一节的内容，当然如果你和我一样前面已经发布了<code>1.0.0</code>，只需要将<code>package.json</code>修改一个版本就好了，我这里修改为<code>2.0.0</code>，然后使用下面命令发布。</p>

<pre><code>$ npm publish
+ react-native-nativemodule-example@2.0.0
</code></pre>

<p>这样，我们就成功发布到了<a href="npmjs.org">npmjs.org</a>。</p>

<h2>三、添加Example，测试是否可用，添加README</h2>

<p>请点击查看<a href="http://www.liuchungui.com/blog/2016/05/02/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-iospian/">ReactNative之原生模块开发并发布——iOS篇</a>中的<code>添加Example，测试是否可用，添加README</code>这一部分内容，基本上一样的。</p>

<h2>参考：</h2>

<p><a href="http://blog.csdn.net/dxpqxb/article/details/8659292">http://blog.csdn.net/dxpqxb/article/details/8659292</a>      <br/>
<a href="http://reactnative.cn/docs/0.25/native-modules-android.html#content">原生模块</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactNative之原生模块开发并发布——iOS篇]]></title>
    <link href="http://www.liuchungui.com/blog/2016/05/02/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-iospian/"/>
    <updated>2016-05-02T19:48:27+08:00</updated>
    <id>http://www.liuchungui.com/blog/2016/05/02/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-iospian</id>
    <content type="html"><![CDATA[<p>前段时间做了个ReactNative的App，发现ReactNative中不少组件并不存在，所以还是需要自己对原生模块进行编写让JS调用，正是因为在这个编写过程中遇到不少问题，发觉了官网文档中许多的不足。所以产生了写一个实践教程的想法，最终有了这么一篇文章。</p>

<p>整篇文章主要以编写一个原生模块为例子，来讲述了我们在编写原生模块所用到的一些知识，并且在整个例子中，配有了完整的实践代码，方便大家理解并调试。除了这些内容，文章还讲述了我们如何将自己编写的原生模块发布到npm上分享给别人使用。希望能够给大家带来帮助，也希望大家将自己编写的原生模块分享出来。</p>

<p>示例代码github地址：<a href="https://github.com/liuchungui/react-native-BGNativeModuleExample">https://github.com/liuchungui/react-native-BGNativeModuleExample</a></p>

<p>编写android原生模块，请看<a href="http://www.liuchungui.com/blog/2016/05/08/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-androidpian/">ReactNative之原生模块开发并发布——android篇</a></p>

<!-- more -->


<h2>准备工作：</h2>

<p>我们需要先创建一个ReactNative工程，使用如下命令创建。</p>

<pre><code>react native init TestProject
</code></pre>

<p>创建好工程之后，我们使用xcode打开<code>TestProject/ios/</code>下的iOS工程。</p>

<h2>一、编写原生模块代码</h2>

<h4>1、创建原生模块</h4>

<p>我们在当前的iOS工程下，创建一个类<code>BGNativeModuleExample</code>，然后在头文件导入RCTBridgeModule.h，让BGNativeModuleExample遵循RCTBridgeModule协议。</p>

<pre><code class="objc">//BGNativeModuleExample.h文件的内容如下
#import &lt;Foundation/Foundation.h&gt;
#import "RCTBridgeModule.h"
@interface BGNativeModuleExample : NSObject &lt;RCTBridgeModule&gt;
@end
</code></pre>

<p>在<code>BGNativeModuleExample.m</code>文件中，我们需要实现<code>RCTBridgeModule</code>协议。为了实现<code>RCTBridgeModule</code>协议，我们的类需要包含RCT_EXPORT_MODULE()宏。这个宏也可以添加一个参数用来指定在Javascript中访问这个模块的名字。如果不指定，默认会使用这个类的名字。</p>

<p>在这里，我们指定了模块的名字为<code>BGNativeModuleExample</code>。</p>

<pre><code class="js">RCT_EXPORT_MODULE(BGNativeModuleExample);
</code></pre>

<p>实现了RCTBridgeModule协议之后，我们就可以在js中如下获取到我们创建的原生模块。</p>

<pre><code>import { NativeModules } from 'react-native';
var BGNativeModuleExample = NativeModules.BGNativeModuleExample;
</code></pre>

<p>需要注意的是，RCT_EXPORT_MODULE宏传递的参数不能是OC中的字符串。如果传递@&ldquo;BGNativeModuleExample"，那么我们导出给JS的模块名字其实是@"BGNativeModuleExample"，使用BGNativeModuleExample就找不到了。在这里，我们其实可以通过打印<code>NativeModules</code>来查找到我们创建的原生模块。</p>

<h4>2、为原生模块添加方法</h4>

<p>我们需要明确的声明要给JS导出的方法，否则ReactNative不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p>

<pre><code class="objc">RCT_EXPORT_METHOD(testPrint:(NSString *)name info:(NSDictionary *)info) {
  RCTLogInfo(@"%@: %@", name, info);
}
</code></pre>

<p>在JS中，我们可以这样调用这个方法：</p>

<pre><code class="js">    BGNativeModuleExample.testPrint("Jack", {
      height: '1.78m',
      weight: '7kg'
    });
</code></pre>

<h4>3、回调函数</h4>

<blockquote><p>警告  <br/>
本章节内容目前还处在实验阶段，因为我们还并没有太多的实践经验来处理回调函数。</p></blockquote>

<p>回调函数，在官方的文档中是有上面的一个警告，不过在使用过程暂时未发现问题。在OC中，我们添加一个<code>getNativeClass</code>方法，将当前模块的类名回调给JS。</p>

<pre><code class="objc">RCT_EXPORT_METHOD(getNativeClass:(RCTResponseSenderBlock)callback) {
  callback(@[NSStringFromClass([self class])]);
}
</code></pre>

<p>在JS中，我们通过以下方式获取到原生模块的类名</p>

<pre><code class="js">    BGNativeModuleExample.getNativeClass(name =&gt; {
      console.log("nativeClass: ", name);
    });
</code></pre>

<p><strong>原生模块通常只应调用回调函数一次。但是，它们可以保存callback并在将来调用。</strong>这在封装那些通过“委托函数”来获得返回值的iOS API时最常见。</p>

<h4>4、Promises</h4>

<blockquote><p>原生模块还可以使用promise来简化代码，搭配ES2016(ES7)标准的async/await语法则效果更佳。如果桥接原生方法的最后两个参数是RCTPromiseResolveBlock和RCTPromiseRejectBlock，则对应的JS方法就会返回一个Promise对象。</p></blockquote>

<p>我们通过Promiss来实现原生模块是否会响应方法，响应则返回YES，不响应则返回一个错误信息，代码如下：</p>

<pre><code class="objc">RCT_REMAP_METHOD(testRespondMethod,
                 name:(NSString *)name
                 resolver:(RCTPromiseResolveBlock)resolve
                 rejecter:(RCTPromiseRejectBlock)reject) {
  if([self respondsToSelector:NSSelectorFromString(name)]) {
    resolve(@YES);
  }
  else {
    reject(@"-1001", @"not respond this method", nil);
  }
}
</code></pre>

<p>在JS中，我们有两种方式调用，第一种是通过<code>then....catch</code>的方式：</p>

<pre><code class="js">BGNativeModuleExample.testRespondMethod("dealloc")
    .then(result =&gt; {
      console.log("result is ", result);
    })
    .catch(error =&gt; {
      console.log(error);
    });
</code></pre>

<p>第二种是通过<code>try...catch</code>来调用，与第一种相比，第二种会报警告”Possible Unhandled Promiss Rejection (id:0)“。</p>

<pre><code>    async testRespond() {
    try {
      var result = BGNativeModuleExample.testRespondMethod("hell");
      if(result) {
        console.log("respond this method");
      }
    } catch (e) {
      console.log(e);
    }
  }
</code></pre>

<p><strong>注意: 如果使用Promiss我们不需要参数，则在OC去掉name那一行就行了；如果需要多个参数，在name下面多加一行就行了，注意它们之间不需要添加逗号。</strong></p>

<h4>5、多线程</h4>

<p>我们这里操作的模块没有涉及到UI，所以专门建立一个串行的队列给它使用，如下：</p>

<pre><code>return dispatch_queue_create("com.liuchungui.demo", DISPATCH_QUEUE_SERIAL);
</code></pre>

<blockquote><p>注意: 在模块之间共享分发队列   <br/>
methodQueue方法会在模块被初始化的时候被执行一次，然后会被React Native的桥接机制保存下来，所以你不需要自己保存队列的引用，除非你希望在模块的其它地方使用它。但是，如果你希望在若干个模块中共享同一个队列，则需要自己保存并返回相同的队列实例；仅仅是返回相同名字的队列是不行的。</p></blockquote>

<p>更多线程的操作细节可以参考<a href="http://reactnative.cn/docs/0.24/native-modules-ios.html#content">http://reactnative.cn/docs/0.24/native-modules-ios.html#content</a></p>

<h4>6、导出常量</h4>

<p>原生模块可以导出一些常量，这些常量在JavaScript端随时都可以访问。用这种方法来传递一些静态数据，可以避免通过bridge进行一次来回交互。</p>

<p>OC中，我们实现<code>constantsToExport</code>方法，如下：</p>

<pre><code class="objc">- (NSDictionary *)constantsToExport {
  return @{ @"BGModuleName" : @"BGNativeModuleExample",
            TestEventName: TestEventName
            };
}
</code></pre>

<p>JS中，我们打印一下这个常量</p>

<pre><code class="js">console.log("BGModuleName value is ", BGNativeModuleExample.BGModuleName);
</code></pre>

<p>但是注意这个常量仅仅在初始化的时候导出了一次，所以即使你在运行期间改变constantToExport返回的值，也不会影响到JavaScript环境下所得到的结果。</p>

<h4>7、给JS发送事件</h4>

<p>即使没有被JS调用，本地模块也可以给JS发送事件通知。最直接的方式是使用<code>eventDispatcher</code>。</p>

<p>在这里，我们为了能够接收到事件，我们开一个定时器，每一秒发送一次事件。</p>

<pre><code class="objc">#import "BGNativeModuleExample.h"
#import "RCTEventDispatcher.h"
@implementation BGNativeModuleExample
@synthesize bridge = _bridge;
- (instancetype)init {
  if(self = [super init]) {
    [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(sendEventToJS) userInfo:nil repeats:YES];
  }
  return self;
}

- (void)receiveNotification:(NSNotification *)notification {
  [self.bridge.eventDispatcher sendAppEventWithName:TestEventName body:@{@"name": @"Jack"}];
}
@end
</code></pre>

<p>在JS中，我们这样接收事件</p>

<pre><code>NativeAppEventEmitter.addListener(BGNativeModuleExample.TestEventName, info =&gt; {
      console.log(info);
    });
</code></pre>

<p><strong>注意： 编写OC代码时，需要添加<code>@synthesize bridge = _bridge;</code>，否则接收事件的时候就会报<code>Exception -[BGNativeModuleExample brige]; unrecognized selector sent to instance</code>的错误。</strong></p>

<p>上面原生代码就编写好了，主要以代码实践为主，弥补官方文档中的一些不足，如果要需要了解更多的原生模块封装的知识，可以参考<a href="http://reactnative.cn/docs/0.22/native-modules-ios.html#content">原生模块</a>，也可以参考官方的源代码。</p>

<h2>二、发布上线</h2>

<p>我们按照上面步骤编写好原生模块之后，接下来将我们写的原生模块发布到npm。</p>

<h4>建立一个github仓库</h4>

<p>在github上创建一个仓库<code>react-native-BGNativeModuleExample</code>，克隆到本地，并且创建一个ios文件夹。</p>

<pre><code>git clone https://github.com/liuchungui/react-native-BGNativeModuleExample.git
cd react-native-BGNativeModuleExample
mkdir ios
</code></pre>

<h4>创建静态库，设置Header Search Paths</h4>

<p>由于ReactNative的组件都是一个个静态库，我们发布上线给别人使用的话，也需要建立静态库。</p>

<p>首先，我们使用xcode建立静态库，取名为<code>BGNativeModuleExample</code>。使用xcode打开创建的静态库，添加一行<code>Header Search Paths</code>，值为<code>$(SRCROOT)/../../react-native/React</code>，并设置为<code>recursive</code>。
<img src="http://ww2.sinaimg.cn/large/7746cd07jw1f3h69rwj3oj212s0r7dm6.jpg" alt="" /></p>

<p>然后，我们将前面编写原生模块代码的<code>BGNativeModuleExample.h</code>和<code>BGNativeModuleExample.m</code>文件替换静态库中的文件。当然，如果我们编写的原生模块依赖其它第三方包的话，我们也需要都copy过来并配置好。</p>

<p>其后，我们将创建的静态库中的文件，全部copy到<code>react-native-BGNativeModuleExample</code>下的ios目录下。ios文件目录如下：</p>

<pre><code>|____BGNativeModuleExample
| |____BGNativeModuleExample.h
| |____BGNativeModuleExample.m
|____BGNativeModuleExample.xcodeproj
</code></pre>

<p>最后，我们需要在react-native-BGNativeModuleExample目录下创建一个index.js，它是整个原生模块的入口，我们这里只是将原生进行导出。</p>

<pre><code>//index.js
import React, { NativeModules } from 'react-native';
module.exports = NativeModules.BGNativeModuleExample;
</code></pre>

<h4>发布到npm</h4>

<p>首先，初始化package.json
在发布到npm时，我们需要创建一个<code>package.json</code>文件，这个文件包含了module的所有信息，比如名称、版本、描述、依赖、作者、license等。
我们在react-native-BGNativeModuleExample根目录下使用<code>npm init</code>命令来创建<code>package.json</code>，系统会提示我们输入所需的信息，不想输入的直接按下<code>Enter</code>跳过。</p>

<pre><code>$ npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help json` for definitive documentation on these fields
and exactly what they do.

Use `npm install &lt;pkg&gt; --save` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
name: (react-native-BGNativeModuleExample)
</code></pre>

<p>输入完成之后，系统会要我们确认文件的内容是否有误，如果没有问题直接输入<code>yes</code>，那么<code>package.json</code>就创建好了。
我这里创建的package.json文件如下：</p>

<pre><code>{
  "name": "react-native-nativemodule-example",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/liuchungui/react-native-BGNativeModuleExample.git"
  },
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/liuchungui/react-native-BGNativeModuleExample/issues"
  },
  "homepage": "https://github.com/liuchungui/react-native-BGNativeModuleExample#readme"
}
</code></pre>

<p>如果我们编写的原生模块依赖于其他的原生模块，我们需要在<code>package.json</code>添加依赖关系，我们这里由于没有相关依赖，所以不需要添加：
<code>
"dependencies": {
}
</code></p>

<p><strong>初始化完package.json，我们就可以发布到npm上面了。</strong></p>

<p>如果没有npm的账号，我们需要在注册一个账号，这个账号会被添加到npm本地的配置中，用来发布module用。</p>

<pre><code>$ npm adduser   
Username: your name
Password: your password
Email: yourmail@gmail.com
</code></pre>

<p>成功之后，npm会把认证信息存储在~/.npmrc中，并且可以通过以下命令查看npm当前使用的用户：</p>

<pre><code>$ npm whoami 
</code></pre>

<p>以上完成之后，我们就可以进行发布了。</p>

<pre><code>$npm publish
+ react-native-nativemodule-example@1.0.0
</code></pre>

<p>到这里，我们已经成功把module发布到了<a href="npmjs.org">npmjs.org</a>。</p>

<h2>三、添加Example，测试是否可用，添加README</h2>

<p>我们在<code>react-native-BGNativeModuleExample</code>目录下创建一个Example的ReactNative工程，并且通过<code>rnpm install react-native-nativemodule-example</code>命令安装我们发布的<code>react-native-nativemodule-example</code>模块。</p>

<pre><code>$ rnpm install react-native-nativemodule-example
TestProject@0.0.1 /Users/user/github/TestProject
└── react-native-nativemodule-example@1.0.0 

rnpm-link info Linking react-native-nativemodule-example ios dependency 
rnpm-link info iOS module react-native-nativemodule-example has been successfully linked 
rnpm-link info Module react-native-nativemodule-example has been successfully installed &amp; linked 
</code></pre>

<p>上面提示安装并且link成功，我们就可以在js中进行使用了。</p>

<pre><code>import BGNativeModuleExample from 'react-native-nativemodule-example';

BGNativeModuleExample.testPrint("Jack", {
    height: '1.78m',
    weight: '7kg'
});
</code></pre>

<p>添加<code>.npmignore</code>文件，并且添加如下内容：</p>

<pre><code>Example/
.git
.gitignore
.idea
</code></pre>

<p>这样的话，我们npm进行发布的时候，就不会将Example发布到npm上了。</p>

<h4>最后，我们在发布上线之后还需要编写README文件。</h4>

<p>README文件是非常重要的，如果没有README文件，别人看到我们的原生组件，根本就不知道我们这个组件是用来干啥的。所以，我们很有必要添加一个README文件，这个文件需要告诉别人我们这个原生组件是干什么的、如何安装、API、使用手册等等。</p>

<h2>原生模块升级，发布新版本</h2>

<p>当我们添加新代码或者修复bug后，需要发布新的版本，我们只需要修改package.json文件中的<code>version</code>的值就行了，然后使用<code>npm publish</code>进行发布。</p>

<h2>总结</h2>

<p>主要说了编写原生模块代码中常用的一些知识，并且通过代码实践和总结了编写过程的一些注意的地方，并总结了下如何发布上线到npm上。不足的地方是没有加上自动化测试，待后续研究。</p>

<h2>参考</h2>

<p><a href="http://weizhifeng.net/how-to-publish-a-node-module.html">如何发布Node模块到NPM社区</a></p>

<p><a href="http://reactnative.cn/docs/0.22/native-modules-ios.html#content">原生模块</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactNative之Flex布局总结]]></title>
    <link href="http://www.liuchungui.com/blog/2016/04/04/reactnativezhi-flexbu-ju-zong-jie/"/>
    <updated>2016-04-04T18:35:53+08:00</updated>
    <id>http://www.liuchungui.com/blog/2016/04/04/reactnativezhi-flexbu-ju-zong-jie</id>
    <content type="html"><![CDATA[<p>从二月份开始学习ReactNative到现在已经有两个月了，零碎的记录了很多笔记，一直想写一些ReactNative相关的东西，奈何感觉自己学习的还比较浅陋，而且笔记比较杂乱，不知从何而起，所以迟迟没有动笔。清明三天假，决定无论如何都得整一篇出来。本来是想整一篇ReactNative布局篇的，但是看看那么多布局属性，自己对CSS又不是特别熟悉，布局篇从何谈起？所以，专门拿出ReactNative中布局比较重要的一个点Flex布局来做下总结，算是开启ReactNative篇章。</p>

<p>Flex是Flexible Box的缩写，意为“弹性布局”，2009年它由W3C提出了一种新的网页布局方案。而FaceBook将这个布局也应用到React和ReactNative两个项目当中。而在ReactNative当中，网页的有些属性和属性的值并不支持，下面来看看ReactNative当中支持的属性。（如果对于Flex布局不太了解的同学，可以看看<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a>）</p>

<!-- more -->


<h2>一、容器属性：</h2>

<p>ReactNative支持的容器属性有flexDirection、flexWrap、justifyContent和alignItems。</p>

<h4>1、 flexDirection属性</h4>

<p>flexDirection属性决定了主轴的方向，它有两个值：</p>

<ul>
<li>row: 主轴为水平方向，起点在左端</li>
<li>column:  主轴为垂直方向，起点在顶部</li>
</ul>


<h4>2、flexWrap属性</h4>

<p>flexWrap属性定义一条轴线排不下时是否折行。它有两个值，分别是'wrap'和'nowrap'，分别代表支持换行和不支持换行，默认是'nowrap'。</p>

<h4>3、justifyContent属性</h4>

<p>主轴的对齐方式，默认为'flex-start'，它的值有五个：</p>

<ul>
<li>flex-start：主轴起点对齐</li>
<li>flex-end：主轴终点</li>
<li>center：居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等</li>
<li>space-around: 每个项目两侧的间隔相等。项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>


<h4>4、alignItems属性</h4>

<p>交叉轴的对齐方式，默认为'stretch'，它有四个值：</p>

<ul>
<li>flex-start: 交叉轴的起点对齐</li>
<li>flex-end: 交叉轴的终点对齐</li>
<li>center: 交叉轴的中心对齐</li>
<li>stretch: 容器中的所有项目拉伸填满整个容器</li>
</ul>


<h2>二、项目属性</h2>

<h4>1、flex属性</h4>

<p>是否让当前的视图尽量占用更大的空间，这个属性可能使项目属性justifyContent失效。有两个值0和1，0代表否，1代表是，默认为0。</p>

<h3>2、alignSelf属性</h3>

<p>允许单个项目在交叉轴方向上与其他项目不一样的对齐方式，可覆盖alignItems属性，它的值有五个，除了'auto'，其他都与alignItem属性完全一致，默认为'auto'。</p>

<h2>后话</h2>

<p>在刚开始接触ReactNative的时候，对于我这么一个从未有过前端开发的iOS开发程序员，两个地方直接让我懵了，一是里面的语法，另外一个就是Flex布局。布局当中其它例如bottom、left、margin等等属性都能从字面意思理解，而Flex布局，确实是从没见过的东西，不理解里面的概念根本没法用。好在找到了阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a>的这篇文章，快速的掌握了Flex布局。
在这几天ReactNative的开发当中，越发觉得Flex布局的重要性，能将上面的属性全部理解清楚的话，并且灵活使用，必然会让ReactNative开发之旅更加得心应手。</p>

<h2>参考：</h2>

<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a>  <br/>
<a href="http://reactnative.cn/docs/flexbox.html#content">弹性盒(Flexbox)</a></p>
]]></content>
  </entry>
  
</feed>
