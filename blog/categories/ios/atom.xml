<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | liuchungui's Blog]]></title>
  <link href="http://www.liuchungui.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://www.liuchungui.com/"/>
  <updated>2016-03-15T00:05:35+08:00</updated>
  <id>http://www.liuchungui.com/</id>
  <author>
    <name><![CDATA[刘春桂]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Runtime之类与对象总结]]></title>
    <link href="http://www.liuchungui.com/blog/2016/03/14/runtimezhi-lei-yu-dui-xiang-zong-jie/"/>
    <updated>2016-03-14T23:30:27+08:00</updated>
    <id>http://www.liuchungui.com/blog/2016/03/14/runtimezhi-lei-yu-dui-xiang-zong-jie</id>
    <content type="html"><![CDATA[<p>以前在使用<a href="https://github.com/elado/jastor">jastor</a>解析Json成model的时候里面涉及到了Runtime里面的知识，所以专门看了<a href="http://blog.jobbole.com/79566/">Objective-C Runtime 运行时之一到六</a>这一系列的文章，整个Jastor也就懂了，现在非常出名的框架<a href="https://github.com/Mantle/Mantle">Mantle</a>，<a href="https://github.com/icanzilb/JSONModel">JSONModel</a>也都是差不多的原理。但是，一年之后的今天重新再看的时候，发现大概思路知道，但是具体的一些细节实现需要写的时候，却一时上不了手，所以重新看了<a href="http://blog.jobbole.com/79566/">Objective-C Runtime 运行时</a>一系列，然后整理了一下，细节部分附上一些代码，方便以后查找。</p>

<!-- more -->


<h2>一、对象、类、元类之间的关系</h2>

<ul>
<li>每个对象是一个objc_object结构体，此结构体只有一个元素即指向其类的isa指针，isa指针的类型为Class。(Class的结构体后面有）</li>
<li>每个类也是一个对象，它的isa指针指向它的元类(meta class)，一般元类都是唯一的。</li>
<li>每个元类也是一个对象，它的isa指针指向NSObject的元类，而NSObject的元类指向它本身（即NSObject元类）</li>
<li>而每个类的super class都指向它的父类，直至NSObject，NSObject的super class为null。</li>
<li>每个元类的super class都指向它的父元类，直至NSObject元类。NSObject元类的父元类是NSObject，NSObject的父类是nil。</li>
</ul>


<p>注：上面使用代码测试过，主要使用object_getClass、class_getSuperClass和objc_getMetaClass来获取类、父类、元类，然后打印指针进行查看。</p>

<h2>二、类与对象基础数据结构</h2>

<p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针，它的定义如下：</p>

<pre><code class="objc">typedef struct objc_class *Class;
</code></pre>

<p>查看objc/runtime.h中objc_class结构体的定义如下：</p>

<pre><code>struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class super_class                       OBJC2_UNAVAILABLE;  // 父类
    const char *name                        OBJC2_UNAVAILABLE;  // 类名
    long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0
    long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识
    long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小
    struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表
    struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表
    struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存
    struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表
#endif

} OBJC2_UNAVAILABLE;
</code></pre>

<h2>三、调用方法时的流程</h2>

<p>首先到当前对象所属的类中的方法缓存列表中查找这个方法，如果没有则到该类的方法定义链表中查找方法，如果查找到，则执行这个方法将返回值返回给原调用对象，并且将这个方法加入缓存cache当中；如果没有查找到则通过super_class找到它的父类，到它的父类中查找。</p>

<p>想了解更多Runtime方法调用知识，请看<a href="http://blog.jobbole.com/79574/">Objective-C Runtime 运行时之三：方法与消息</a></p>

<h2>四、类与对象的操作函数</h2>

<p>runtime提供了大量的函数来操作类与对象，操作类的函数一般前缀是class，而操作对象的函数一般前缀是objc。</p>

<h4>1、类相关操作函数</h4>

<pre><code>// 获取类的类名
const char * class_getName ( Class cls );
// 获取类的父类
Class class_getSuperclass ( Class cls );

// 判断给定的Class是否是一个元类
BOOL class_isMetaClass ( Class cls );
// 获取实例大小
size_t class_getInstanceSize ( Class cls );
</code></pre>

<h4>2、成员变量相关操作函数</h4>

<pre><code>// 获取类中指定名称实例成员变量的信息
Ivar class_getInstanceVariable ( Class cls, const char *name );

// 获取类成员变量的信息
Ivar class_getClassVariable ( Class cls, const char *name );

// 添加成员变量
BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );

// 获取整个成员变量列表
Ivar * class_copyIvarList ( Class cls, unsigned int *outCount );
</code></pre>

<p>需要注意：</p>

<ul>
<li>class_copyIvarList：获取的是所有成员实例属性，与property获取不一样。</li>
<li>class_addIvar: <strong>OC不支持往已存在的类中添加实例变量</strong>，因此不管是系统库提供的类，还是我们自定义的类，都无法动态给它添加成员变量。<strong>但，如果是我们通过运行时来创建的类，我们可以使用class_addIvar来添加。不过，需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。</strong>另外，<strong>这个类也不能是元类</strong>。</li>
</ul>


<p>代码测试：</p>

<pre><code>/**
 *  测试成员变量
 */
- (void)testIvar {
    unsigned int outCount;
    if(class_addIvar([Student class], "_hell", sizeof(id), log2(sizeof(id)), "@")) {
        NSLog(@"Add Ivar Success!");
    }
    else {
        NSLog(@"Add Ivar failed!");
    }
    Ivar *ivarList = class_copyIvarList([Student class], &amp;outCount);
    for (unsigned int i = 0; i &lt; outCount; i++) {
        Ivar ivar = ivarList[i];
        const char *ivarName = ivar_getName(ivar);
        ptrdiff_t offset = ivar_getOffset(ivar);
        const char *types = ivar_getTypeEncoding(ivar);
        NSLog(@"ivar:%s, offset:%zd, type:%s", ivarName, offset, types);
    }
    free(ivarList);
}
</code></pre>

<p>注意：class_addIvar中第三个参数设置类型的大小，第四个参数设置对齐，对齐传递log2(size)，具体原因参考：<a href="http://stackoverflow.com/questions/33184826/what-does-class-addivars-alignment-do-in-objective-c">http://stackoverflow.com/questions/33184826/what-does-class-addivars-alignment-do-in-objective-c</a></p>

<h4>3、属性操作函数</h4>

<pre><code>// 获取指定的属性
objc_property_t class_getProperty ( Class cls, const char *name );

// 获取属性列表
objc_property_t * class_copyPropertyList ( Class cls, unsigned int *outCount );

// 为类添加属性
BOOL class_addProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );

// 替换类的属性
void class_replaceProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );
</code></pre>

<p>这一种方法也是针对ivar来操作的，不过它只操作那些property的值，包括扩展中的property。</p>

<p>代码实践：</p>

<pre><code>- (void)testProperty {
    /**
     *  添加property
     */
    objc_property_attribute_t attribute1 = {"T", "@\"NSString\""};
    objc_property_attribute_t attribute2 = {"C", ""};
    objc_property_attribute_t attribute3 = {"N", ""};
    objc_property_attribute_t attribute4 = {"V", "_lcg"};
    objc_property_attribute_t attributesList[] = {attribute1, attribute2, attribute3, attribute4};
    if(class_addProperty([Student class], "lcg", attributesList, 4)) {
        NSLog(@"add property success!");
    }
    else {
        NSLog(@"add property failure!");
    }

    /**
     *  打印property的name和property_attribute_t
     */
    unsigned int outCount;
    objc_property_t *propertyList = class_copyPropertyList([Student class], &amp;outCount);
    for (unsigned int i = 0; i &lt; outCount; i++) {
        objc_property_t property = propertyList[i];
        const char *propertyName = property_getName(property);
        const char *attribute = property_getAttributes(property);
        NSLog(@"propertyName: %s, attribute: %s", propertyName, attribute);

        unsigned int attributeCount;
        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;attributeCount);
        for (unsigned int j = 0; j &lt; attributeCount; j++) {
            objc_property_attribute_t attribute = attributeList[j];
            const char *name = attribute.name;
            const char *value = attribute.value;
            NSLog(@"attribute name: %s, value: %s", name, value);
        }
    }
}
</code></pre>

<p>上面代码有几个知识点需要说一下：</p>

<p>(1) 其中property_attribute的相关内容需要说明下。</p>

<p>   property_attribute为<strong>T@&ldquo;NSString&rdquo;,&amp;,N,V_exprice</strong>时：</p>

<ul>
<li><strong>T</strong> 是固定的，放在第一个</li>
<li><strong>@&ldquo;NSString&rdquo;</strong> 代表这个property是一个字符串对象</li>
<li><strong>&amp;</strong> 代表强引用，其中与之并列的是：'C'代表Copy，'&amp;&lsquo;代表强引用，'W'表示weak，assign为空，默认为assign。</li>
<li><strong>N</strong> 区分的nonatomic和atomic，默认为atomic，atomic为空，'N'代表是nonatomic</li>
<li><strong>V_exprice</strong> V代表变量，后面紧跟着的是成员变量名，代表这个property的成员变量名为_exprice。</li>
</ul>


<p> property_attribute为<strong>T@&ldquo;NSNumber&rdquo;,R,N,V_yearsOld</strong>时：</p>

<ul>
<li><strong>T</strong> 是固定的，放在第一个</li>
<li><strong>@&ldquo;NSNumber&rdquo;</strong> 代表这个property是一个NSNumber对象</li>
<li><strong>R</strong> 代表readOnly属性，readwrite时为空</li>
<li><strong>N</strong> 区分的nonatomic和atomic，默认为atomic，atomic为空，'N'代表是nonatomic</li>
<li><strong>V_yearsOld</strong> V代表变量，后面紧跟着的是成员变量名，代表这个property的成员变量名为_yearsOld。</li>
</ul>


<p>使用例子参考：<a href="http://www.tuicool.com/articles/aY3Ujii">http://www.tuicool.com/articles/aY3Ujii</a>  <br/>
官方参考：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6">Property Type</a></p>

<p>（2） 添加property，property_attribute_t是一个结构体，没有具体创建的方法，我们就只能使用{}这样结构体直接赋值过去。而且，添加property成功之后，它并不会生成<strong>实例属性、setter方法和getter方法</strong>。如果要真正调用的话，还需要我们自己添加对应的setter和getter方法。  <br/>
详情使用请见：<a href="http://blog.csdn.net/meegomeego/article/details/18356169">http://blog.csdn.net/meegomeego/article/details/18356169</a></p>

<h4>4、协议相关函数</h4>

<pre><code>// 添加协议
BOOL class_addProtocol ( Class cls, Protocol *protocol );

// 返回类是否实现指定的协议
BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );

// 返回类实现的协议列表
Protocol * class_copyProtocolList ( Class cls, unsigned int *outCount );
</code></pre>

<p>代码实践：</p>

<pre><code>- (void)testProtocolList {
    //添加协议
    Protocol *p = @protocol(StudentDataSource);
    if(class_addProtocol([Student class], p)) {
        NSLog(@"添加协议成功!");
    }
    else {
        NSLog(@"添加协议失败!");
    }

    //判断是否实现了指定的协议
    if(class_conformsToProtocol([Student class], p)) {
        NSLog(@"遵循 %s协议", protocol_getName(p));
    }
    else {
        NSLog(@"不遵循 %s协议", protocol_getName(p));
    }

    //获取类的协议列表
    unsigned int outCount;
    Protocol * __unsafe_unretained *protocolList = class_copyProtocolList([Student class], &amp;outCount);
    for (unsigned int i = 0; i &lt; outCount; i++) {
        Protocol *protocol = protocolList[i];
        const char *name = protocol_getName(protocol);
        NSLog(@"%s", name);
    }
    free(protocolList);
}
</code></pre>

<p><strong>注意：可以使用runtime添加协议</strong></p>

<h4>6、版本号（Version)</h4>

<p>版本的使用两个方法，获取版本和设置版本，请看代码：</p>

<pre><code>- (void)testVersion {
    int version = class_getVersion([Student class]);
    NSLog(@"%d", version);
    class_setVersion([Student class], 100);
    version = class_getVersion([Student class]);
    NSLog(@"%d", version);
}
</code></pre>

<h2>五、动态创建类和对象</h2>

<h4>1、动态创建类</h4>

<p>涉及以下函数</p>

<pre><code>// 创建一个新类和元类
Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes );

// 销毁一个类及其相关联的类
void objc_disposeClassPair ( Class cls );

// 在应用中注册由objc_allocateClassPair创建的类
void objc_registerClassPair ( Class cls );
</code></pre>

<p>注意：objc_disposeClassPair只能销毁由objc_allocateClassPair创建的类，当有实例存在或者它的子类存在时，调用这个函数会抛出异常。</p>

<p>代码实践：</p>

<pre><code>- (void)testCreateClass {
    Class cls = objc_allocateClassPair([Person class], "Teacher", 0);
    //添加成员变量，只能在运行时创建类添加，并且是在objc_allocateClassPair与objc_registerClassPair之间
    if(class_addIvar(cls, "_level", sizeof(id), log2(sizeof(id)), "@\"NSString\"")) {
        NSLog(@"添加_level成员变量成功");
    }
    else {
        NSLog(@"添加_level成员变量失败");
    }
    objc_registerClassPair(cls);

    /**
     *  当有实例存在不能销毁类，所以讲代码放到里面
     */
    {
        //创建对象
        Person *p = [[cls alloc] init];
        NSLog(@"%@", [p class]);
        [p printInfo];
        //设置值
        [p setValue:@"高级讲师" forKey:@"level"];
        NSString *level = [p valueForKey:@"level"];
        NSLog(@"level: %@", level);
    }

    //销毁类，当有实例存在的时候是不能销毁类
    objc_disposeClassPair(cls);
}
</code></pre>

<h2>六、实例操作函数</h2>

<pre><code>// 返回指定对象的一份拷贝
id object_copy ( id obj, size_t size );

// 释放指定对象占用的内存
id object_dispose ( id obj );
// 修改类实例的实例变量的值
Ivar object_setInstanceVariable ( id obj, const char *name, void *value );

// 获取对象实例变量的值
Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );

// 返回指向给定对象分配的任何额外字节的指针
void * object_getIndexedIvars ( id obj );

// 返回对象中实例变量的值
id object_getIvar ( id obj, Ivar ivar );

// 设置对象中实例变量的值
void object_setIvar ( id obj, Ivar ivar, id value );
// 返回给定对象的类名
const char * object_getClassName ( id obj );

// 返回对象的类
Class object_getClass ( id obj );

// 设置对象的类
Class object_setClass ( id obj, Class cls );
</code></pre>

<p>实践代码：</p>

<pre><code>- (void)testInstance {
    Person *p = [Person new];
    //object_copy在ARC下不能使用
//    p = object_copy(p, class_getInstanceSize([Student class]));
    //将p的isa指向Student
    object_setClass(p, [Student class]);
    [(Student *)p setName:@"Jack"];
}
</code></pre>

<p>这里只是简单的将p这个对象的class设置为Student类，其实就是将p对象的isa指针指向Student类，KVO中的isa-swizzling其实就是这样干的。当调用setName:的方法的时候，就调用到了Student类中的setName。不过，这里调用Person类没有，而Student类有的方法会崩溃，报错Heap buffer overflow，就算是在非ARC下使用object_copy也是一样。</p>

<h2>七、获取类的定义</h2>

<pre><code>// 获取已注册的类定义的列表
int objc_getClassList ( Class *buffer, int bufferCount );

// 创建并返回一个指向所有已注册类的指针列表
Class * objc_copyClassList ( unsigned int *outCount );

// 返回指定类的类定义
Class objc_lookUpClass ( const char *name );
Class objc_getClass ( const char *name );
Class objc_getRequiredClass ( const char *name );

// 返回指定类的元类
Class objc_getMetaClass ( const char *name );
</code></pre>

<p>objc_getClassList和objc_copyClassList都是获取所有已注册的类；而objc_lookUpClass获取指定的类，如果没有注册则返回nil；objc_getRequiredClass也是获取指定的类，不过如果这个类不存则，则会崩溃；objc_getMetaClass专门用来获取类的元类，每个类都有一个有效并且唯一的元类，如果这个类没有注册则返回nil。</p>

<p>代码实践：</p>

<pre><code>- (void)testGetClass {
    /**
     *  第一种获取所有注册的类
     */
    Class *bufferClass;
    int numClasses;
    numClasses = objc_getClassList(NULL, 0);
    if(numClasses &gt; 0) {
        bufferClass = (Class *)malloc(sizeof(Class)*numClasses);
        numClasses = objc_getClassList(bufferClass, numClasses);
        NSLog(@"numer of classes: %d", numClasses);
        for (int i = 0; i &lt; numClasses; i++) {
            Class cls = bufferClass[i];
            NSLog(@"class name: %s", class_getName(cls));
        }
        free(bufferClass);
    }

    /**
     *  第二种获取所有注册的类
     */
    unsigned int outCount;
    Class *classLiset = objc_copyClassList(&amp;outCount);
    for (unsigned int i = 0; i &lt; outCount; i++) {
        Class cls = classLiset[i];
        NSLog(@"class name: %s", class_getName(cls));
    }
    free(classLiset);
}
</code></pre>

<p>第二种获取所有注册的类比第一种简单多了，建议使用第二种。</p>

<h2>参考</h2>

<p><a href="http://blog.jobbole.com/79566/">Objective-C Runtime 运行时之一：类与对象</a></p>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">Type Encodings</a></p>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6">Property Type</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BGSession一个基于NSUserDefaults实现的轻量级本地数据存储]]></title>
    <link href="http://www.liuchungui.com/blog/2016/03/04/bgsession/"/>
    <updated>2016-03-04T16:35:38+08:00</updated>
    <id>http://www.liuchungui.com/blog/2016/03/04/bgsession</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/liuchungui/BGSession">BGSession</a>是一个基于NSUserDefaults实现的轻量级数据存储，你只需要简单的继承它，给它添加属性，设置属性的值，就能通过NSUserDefaults同步到本地。</p>

<!-- more -->


<h2>BGSession的由来</h2>

<p>在昨天以前，对于一些轻量级数据，我一共使用过三种方案。</p>

<p>第一种，直接使用NSUserDefaults进行读取，代码如下：</p>

<pre><code class="objc">    //写入
    [[NSUserDefaults standardUserDefaults] setValue:@"Jack" forKey:@"UserDefaults_userName"];
    [[NSUserDefaults standardUserDefaults] synchronize];

    //读取
    NSString *userName = [[NSUserDefaults standardUserDefaults] valueForKey:@"UserDefaults_userName"];
</code></pre>

<p>第二种，数据归档，代码如下：</p>

<pre><code>    //使用归档写入
    NSString *userName = @"Jack";
    NSString *filePath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@"UserNameFile"];
    [NSKeyedArchiver archiveRootObject:userName toFile:filePath];

    //使用解归档读取
    userName = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];
</code></pre>

<p>第三种，建立一个全局的单例，然后给定相应的属性值，存储时的代码如下：</p>

<pre><code>    //写入
    [BGGlobal sharedGlobal].userName = @"Jack";
    //写入文件，我使用的是将整个对象归档到一个文件当中
    [BGGlobal writeToFile];

    //读取
    NSString *userName = [BGGlobal sharedGlobal].userName;
</code></pre>

<p> 比较上面三种方案：  <br/>
 第一种我使用过之后就再也不怎么用了，有段时间几乎遗忘了它，因为使用它真的很麻烦，打出<code>[NSUserDefaults standardUserDefaults]</code>已经感觉很长了，后面还需要输入一个自己定义的key值，虽然可以全局定义常量，但是当常量够多的时候，也不能一时找到，而且设置值之后，如果要写入磁盘，还需要使用<code>[[NSUserDefaults standardUserDefaults] synchronize]</code>同步到本地；读取时和写入类似，需要一个key值。</p>

<p> 第二种，数据归档和第一种一样，存取时比较麻烦，而且因为归档的时候需要不停的读取文件，性能也不好。</p>

<p> 第三种，在全局单例实现<code>NSCoding</code>协议，只需要添加属性值，就可以使用点语法直接存取，存取非常的方便。存储本地时，和<code>[[NSUserDefaults standardUserDefaults] synchronize]</code>类似，使用<code>[BGGlobal writeToFile]</code>全局归档写入文件。</p>

<p> 比较这三种方案，我选择了第三种。第二种，直接舍弃；第一种虽然在性能比第二种更优，但是使用不是很方便，况且我们这是存储轻量级数据，性能差异根本看不出来什么。</p>

<p> 但，在使用过程中，我们遇到了一些问题，就是<code>[BGGlobal writeToFile]</code>会忘记写，从而造成了bug。而且，在整个工程项目中<code>[BGGlobal writeToFile]</code>出现的次数特别的多，这一步是否可以优化掉？</p>

<p> 后来，一致商议，我们项目中将全局单例的global中归档写入文件的方式替换成NSUserDefaults的存储方式，然后在内部实现了同步本地的操作。这样只要我们在外面使用设置新的值时，它会自动同步到本地，而且性能方面更佳。</p>

<p> 但是，在使用过一段时间之后，我发现并不是很方便，因为在使用的时候，##每添加一个字段都需要做如下两步##。</p>

<pre><code> //1、定义一个常量来作为NSUserDefaults的key
 static NSString *const kSessionUserName = @"kSessionUserName";
 //2、在全局单例内部实现getter和setter方法
 - (void)setUserName:(NSString *)userName{
    [self setValue:userName forKey:kSessionUserName];
 }
 - (NSString *)userName{
    return [self getValueForKey:kSessionUserName];
 }
</code></pre>

<p> 这些步骤我们是否可以完全省略呢？</p>

<p> 在一次我自己做项目的时候，我使用全局单例舍弃NSUserDefaults进行存储，仍然使用的是归档的形式，而且那个全局单例继承的是<a href="https://github.com/elado/jastor">jastor</a>，它内部自己实现了归档协议，我只需要每次使用的时候，多添加<code>[BGGlobal writeToFile]</code>同步到本地就行了，比前面使用NSUserDefaults方便很多。</p>

<p> 但是，我一直都认为有更好的实现方案，终于在看runtime和KVO东西的时候想到了一种方案。于是，立马回家写了一个实现了<a href="https://github.com/liuchungui/BGSession">BGSession</a>。</p>

<h2>BGSession实现原理</h2>

<p> BGSession是一个全局单例，主要采用的是KVC/KVO和Runtime进行实现的。使用BGSession作为轻量级数据存储时，只需要继承BGSession，然后在BGSession的派生类添加相关的属性。当给这些属性设置新的值后，BGSession会监听到属性值的变化，然后使用KVC自动将它同步到NSUserDefaults。这样，存取时，我们就可以当做使用单例一样使用，简单方便。</p>

<h2>Github地址</h2>

<p><a href="https://github.com/liuchungui/BGSession">https://github.com/liuchungui/BGSession</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionView动画]]></title>
    <link href="http://www.liuchungui.com/blog/2015/11/24/uicollectionviewdong-hua/"/>
    <updated>2015-11-24T00:00:26+08:00</updated>
    <id>http://www.liuchungui.com/blog/2015/11/24/uicollectionviewdong-hua</id>
    <content type="html"><![CDATA[<h2>一、简单使用</h2>

<p>UICollectionView更新事件有四种分别是<code>插入</code>、<code>删除</code>、<code>刷新</code>、<code>移动</code>，
api使用起来和UITableView类似，具体可以自己在代码中找，如果需要执行多个更新事件，可以放到performBatchUpdates中的updates闭包中作为一组动画，然后全部执行完之后通过completion调回。</p>

<pre><code class="swift">    collectionView.performBatchUpdates({ () -&gt; Void in
                collectionView.insertItemsAtIndexPaths(insertIndexPaths)
                collectionView.moveItemAtIndexPath(currentIndexPath, toIndexPath: toIndexPath)
                }, completion: { (isFinish) -&gt; Void in
            })
</code></pre>

<h2>二、UICollectionView动画</h2>

<p>四种不同的更新事件，系统默认会带有动画，不过是比较简单的。我们可以自定义layout或者继承flowLayout，在内部实现我们自己想要的动画。下面，我们来说说动画的流程，以及系统默认的四种动画内部是如何的，并且通过代码来修改达到自己想要的动画。</p>

<!-- more -->


<h4>CollectionView动画流程</h4>

<p>当我们在外部调用CollectionView相关的api去<code>插入</code>、<code>删除</code>、<code>刷新</code>、<code>移动</code>cell时，首先会通过layout中的<code>layoutAttributesForElementsInRect</code>方法获取更新以后的布局信息，然后通过<code>prepareForCollectionViewUpdates</code>方法来通知layout哪些内容将会发生改变。之后，通过调用layout中的<code>initialLayoutAttributesForAppearingItemAtIndexPath</code>、<code>finalLayoutAttributesForDisappearingItemAtIndexPath</code>方法获取对应indexPath的<code>刚出现时最初布局属性</code>和<code>消失时最终布局属性</code>。而后形成两个动画过程分别是<code>刚出现时最初布局-&gt;更新后布局的出现动画</code>和<code>更新前布局-&gt;消失时最终布局的消失动画</code>，而collectionView中'插入'、'删除'、'刷新'和'移动'动画都是基于这两个动画组合形成的。最后，等这一系列动画执行完之后，最后会调用layout中<code>finalizeCollectionViewUpdates</code>方法，这个方法仍然放在动画块中，我们可以在这个方法当中添加额外的动画。</p>

<p>从上面流程可以看出，在更新的时候，由于<code>更新前布局</code>和<code>更新后布局</code>都是在更新动画前已经设置好了，我们不能去胡乱更改布局，所以我们只能通过<code>initialLayoutAttributesForAppearingItemAtIndexPath</code>和<code>finalLayoutAttributesForDisappearingItemAtIndexPath</code>两个方法来更改<code>刚出现时最初布局属性</code>和<code>消失时最终布局属性</code>，即我们只能更改<code>出现动画的起点</code>和<code>消失动画的终点</code>。</p>

<p>为了更方面的下面说明，引申出两个名词：</p>

<ul>
<li>出现动画：initialLayoutAttributesForAppearingItemAtIndexPath获取对应indexPath的<code>刚出现时最初布局</code>->更新后布局变化过程</li>
<li>消失动画：更新之前的布局->finalLayoutAttributesForDisappearingItemAtIndexPath方法获取对应indexPath的<code>消失时最终布局</code>的变化过程</li>
</ul>


<p>注意，出现动画和消失动画针对的是一个cell单元。</p>

<p>下面我们通过代码示例来实现插入、删除、刷新、移动动画。
代码示例工程：<a href="https://github.com/liuchungui/UICollectionViewAnimationDemo">UICollectionViewAnimationDemo</a></p>

<p>在这个Demo工程中有一个<code>BGSelectImageLayout</code>，它是CollectionView的layout，它的布局方式是水平横向滑动，并且只有一组，每一个普通的cell大小都是<code>itemSize</code>，而选中的cell则宽度是<code>itemSize*2</code>。</p>

<h4>插入动画：</h4>

<p>在当前的布局下，每插入一个cell时，都会影响它后面所有cell布局变化。      <br/>
例如CollectionView有一行三个cell，为了更好的说明将indexPath是(0,0),(0,1),(0,2)标记为0，1，2。当在第1个位置插入一个cell时，如下图</p>

<p><img src="http://ww2.sinaimg.cn/large/7746cd07jw1eyba1ih4nvj20re0fs75l.jpg" alt="" /></p>

<p>而在这个插入过程中，视觉上会有三个动画过程。new插入到位置1为<code>过程1</code>，1移动一个单位到2为<code>过程2</code>，2移动一个单位到一个新的位置3为<code>过程3</code>，如下图：</p>

<p><img src="http://ww3.sinaimg.cn/large/7746cd07jw1eyba58t45gj20yc0g6760.jpg" alt="" /></p>

<p>虽然视觉上只有三个动画过程，但其实有五个动画。其中，过程1是1位置的<code>出现动画</code>；过程2是1位置的<code>消失动画</code>和2位置的<code>出现动画</code>重合而成；过程3是2位置的<code>消失动画</code>和3位置的<code>出现动画</code>。</p>

<p>其中值得注意的三点，一是除了最后一个，前面的cell消失动画与它后面cell出现动画重合，这样看起来就是当前位置的cell向后平移了一个位置；二是最后一个cell只有出现动画，没有消失动画，整个过程<code>出现动画会多一个</code>；三是插入的cell的出现动画是默认是alpha从0到1的淡入效果。</p>

<p>在代码中，想获得一个插入的cell从小变大的出现效果和其它cell整体向后移动一个位置的动画效果，可以如下实现：</p>

<pre><code>    override func initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
        let attributes = super.initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
        if self.insertIndexPathArr.contains(itemIndexPath) {
            attributes?.transform = CGAffineTransformMakeScale(0.0, 0.0)
            attributes?.alpha = 0
        }
        else {
            //设置为前一个item的frame
            attributes?.frame = self.currentFrameWithIndexPath(NSIndexPath(forRow: itemIndexPath.row-1, inSection: itemIndexPath.section))
        }
        return attributes
}
override func finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
         let attributes = super.finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
         attributes?.frame = self.currentFrameWithIndexPath(NSIndexPath(forRow: itemIndexPath.row+1, inSection: itemIndexPath.section))
         return attributes
}
</code></pre>

<p>这里为了看到效果，我在模拟器的Debug模式下勾选了Slow Animations调慢了动画:
<img src="http://ww3.sinaimg.cn/large/7746cd07jw1eyaa2ommv4g208j0frab5.gif" alt="" /></p>

<h4>删除动画：</h4>

<p>在上面的位置1插入一个cell后，cell的数量变成了4个，分别是0、1、2、3，它们对应的indexPath为(0,0)、(0,1)、(0,2)、(0,3)。当要删除位置1的cell时，与插入类似，系统默认也会有三个动画过程，如下图：</p>

<p><img src="http://ww3.sinaimg.cn/large/7746cd07jw1eybbqnkm4cj20xo0dita5.jpg" alt="" /></p>

<p>其中，动画过程1是在位置1执行一个消失动画；过程2是位置1的出现动画和位置2的消失动画重合而成；过程3是位置2的出现动画和位置3的消失动画重合而成。</p>

<p><strong>需要注意的是</strong>，一是与插入不同，重合后的效果是cell向前平移了一个位置；二是最后一个位置只有消失动画没有出现动画，整个过程消失动画数会多一个；三是删除的cell的出现动画默认是从1到0的淡出效果。</p>

<p>在代码中，实现一个与插入相对应的动画，即删除的cell从大到小的淡出效果和其它cell整体向前移动一个位置的效果，可以如下实现：</p>

<pre><code>override func initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
    let attributes = super.initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
    attributes?.frame = self.currentFrameWithIndexPath(NSIndexPath(forRow: itemIndexPath.row+1, inSection: itemIndexPath.section))
    return attributes
}
override func finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
        let attributes = super.finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
    if self.deleteIndexPathArr.contains(itemIndexPath) {
        //这里写成缩放成(0，0)直接就不见了
        attributes?.transform = CGAffineTransformMakeScale(0.1, 0.1)
        attributes?.alpha = 0.0
    }
    else {
        attributes?.frame = self.currentFrameWithIndexPath(NSIndexPath(forRow: itemIndexPath.row-1, inSection: itemIndexPath.section))
    }
    return attributes
}
</code></pre>

<p>效果如下：</p>

<p><img src="http://ww2.sinaimg.cn/large/7746cd07jw1eyaqorep4rg208j0g9wgw.gif" alt="" /></p>

<h4>刷新动画：</h4>

<p>在官方的解释中，刷新是先删除然后插入。其实它就是先执行所有cell的消失动画；在此之后，它又会执行所有cell的出现动画。
在系统当中，需要注意的是默认出现动画是一个alpha从0到1的淡入效果，而消失动画则是alpha从1到0的淡入效果；与插入动画和删除动画不同的是，刷新动画会成对存在，即消失动画与出现动画数量相等。</p>

<p>在这里，实现一个点击某个cell时，当前选中的cell变大的效果，而它旁边的cell被推开的动画效果。在这里我不需要淡入和淡出效果，所以修改了消失时alpha为1.0，代码如下：</p>

<pre><code>override func initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
    let attributes = super.initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
    attributes?.frame = self.lastFrameWithIndexPath(itemIndexPath)
    return attributes
}
override func finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
    let attributes = super.finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
    //注意，这里alpha设置为不透明，系统默认返回是0，即一个淡出的效果
    attributes?.alpha = 1.0
    attributes?.frame = self.currentFrameWithIndexPath(itemIndexPath)
    return attributes
}
</code></pre>

<p>效果如下：</p>

<p><img src="http://ww2.sinaimg.cn/large/7746cd07jw1eyb04xye32g208j0g9755.gif" alt="" /></p>

<h4>移动动画：</h4>

<p>移动一个cell到另一个位置时，会引起当前cell到目标位置之间所有cell布局发生变化，从而形成一系列的动画。在这个动画过程中，每个indexPath都会有一个出现动画和一个消失动画。</p>

<p>例如，在系统默认情况下，0位置cell移动到2位置cell的时候，我们会看到三个动画过程，如下图：</p>

<p><img src="http://ww1.sinaimg.cn/large/7746cd07jw1eyazemzgkzj20qa0bqt9u.jpg" alt="" /></p>

<p>但是，其实它内部执行了六个动画，只是其中两两之间动画重合了而已。其中动画过程1是1位置的消失动画和0位置出现动画重合；动画过程2是0位置的消失动画和2位置的出现动画重合；动画过程3是2位置的消失动画和1位置的出现动画重合。</p>

<p><strong>其中值得注意的有两点：</strong>   <br/>
1、消失动画和出现动画数量相等    <br/>
2、动画的重合与刷新动画不同，与插入和删除动画类似，它们不同位置之间的消失动画与出现动画重合。</p>

<p>在这里，实现一个移动cell时旋转180°到目标位置效果，实现如下：</p>

<pre><code> override func initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
    let attributes = super.initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
    if itemIndexPath == self.afterMoveIndexPath {
        //afterMoveIndexPath的消失动画和beforeMoveIndexPath的出现动画重合
        //init是设置起点，而final设置终点，理论是不重合的
        attributes?.transform3D = CATransform3DMakeRotation(-1*CGFloat(M_PI), 0, 0, -1)
    }
    return attributes
}
override func finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
    let attributes = super.finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
    if self.beforeMoveIndexPath == itemIndexPath {
        //afterMoveIndexPath的消失动画和beforeMoveIndexPath的出现动画重合，设置他们旋转的角度一样，方向相反
        attributes?.transform3D = CATransform3DMakeRotation(-1*CGFloat(M_PI), 0, 0, -1)
    }
    return attributes
}
</code></pre>

<p>效果如下：</p>

<p><img src="http://ww1.sinaimg.cn/large/7746cd07jw1eyb0375fz7g208j0g9go4.gif" alt="" /></p>

<p>上面都是纯颜色，在示例工程<a href="https://github.com/liuchungui/UICollectionViewAnimationDemo">UICollectionViewAnimationDemo</a>中，我还添加了一个图片的<code>BGSimpleImageSelectCollectionViewDemo2</code>。布局基本上相同，唯一不同的是图片因为上下不可以倒转，没办法做到统一的旋转180°。</p>

<p>效果如下：</p>

<p><img src="http://ww3.sinaimg.cn/large/7746cd07jw1eybewu3qyxg208j0g9k2r.gif" alt="" /></p>

<h2>总结：</h2>

<p>1、CollectionView更新时，执行动画的时候会访问layout中哪些api，整个流程是如何形成的        <br/>
2、修改CollectionView动画就是修改出现动画的起点和消失动画的终点，即layout当中的initialLayoutAttributesForAppearingItemAtIndexPath和finalLayoutAttributesForDisappearingItemAtIndexPath方法进行修改。     <br/>
3、插入、删除、刷新、移动内部执行哪些动画，我们如何去修改。</p>

<h2>参考：</h2>

<p><a href="http://objccn.io/issue-12-5/">Collection View 动画</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionView之自定义Layout]]></title>
    <link href="http://www.liuchungui.com/blog/2015/11/06/uicollectionviewzhi-zi-ding-yi-layout/"/>
    <updated>2015-11-06T00:00:26+08:00</updated>
    <id>http://www.liuchungui.com/blog/2015/11/06/uicollectionviewzhi-zi-ding-yi-layout</id>
    <content type="html"><![CDATA[<p>当我们使用系统自带的UICollectionViewFlowLayout无法实现我们的布局时，我们就可以考虑自定义layout。     <br/>
所以，了解并学习一下自定义Layout是很有必要。    <br/>
其实可以分三个步骤：</p>

<ol>
<li>覆写prepareLayout方法，并在里面事先就计算好必要的布局信息并存储起来。</li>
<li>基于prepareLayout方法中的布局信息，使用collectionViewContentSize方法返回UICollectionView的内容尺寸。</li>
<li>使用layoutAttributesForElementsInRect:方法返回指定区域cell、Supplementary View和Decoration View的布局属性。</li>
</ol>


<!-- more -->


<p>了解了自定义布局的三个主要步骤，我们来通过自定义布局的方式用UICollectionView实现grideView。当然，grideView使用<code>UICollectionViewFlowLayout</code>就可以轻易实现，这里我们只是学习了解一下自定义布局的过程，所以拿grideView这个经常用的来作为例子。</p>

<p>我们创建一个新的工程<a href="https://github.com/liuchungui/BGCustomLayoutCollectionViewDemo">BGCustomLayoutCollectionViewDemo</a>。然后创建一个UICollectionViewLayout的子类对象<code>BGGrideLayout</code>，它就是我们自定义layout对象。</p>

<h3>在BGGrideLayout里面，我们首先覆写prepareLayout方法。</h3>

<p>prepareLayout是专门用来准备布局的，在<code>prepareLayout</code>方法里面我们可以事先就计算后面要用到的布局信息并存储起来，防止后面方法多次计算，提高性能。例如，我们可以在此方法就计算好每个cell的属性、整个CollectionView的内容尺寸等等。此方法在布局之前会调用一次，之后只有在调用<code>invalidateLayout</code>、<code>shouldInvalidateLayoutForBoundsChange:</code>返回<code>YES</code>和<code>UICollectionView刷新</code>的时候才会调用。</p>

<p>而在BGGrideLayout的prepareLayout方法中，我们有两个目的：    <br/>
一是获取对应indexPath的<code>UICollectionViewLayoutAttributes</code>对象，并存储到二维数组<code>layoutInfoArr</code>当中；   <br/>
二是计算出内容尺寸并保存到全局变量<code>contentSize</code>当中。     <br/>
代码如下：</p>

<pre><code class="objc">- (void)prepareLayout{
    [super prepareLayout];
    NSMutableArray *layoutInfoArr = [NSMutableArray array];
    NSInteger maxNumberOfItems = 0;
    //获取布局信息
    NSInteger numberOfSections = [self.collectionView numberOfSections];
    for (NSInteger section = 0; section &lt; numberOfSections; section++){
        NSInteger numberOfItems = [self.collectionView numberOfItemsInSection:section];
        NSMutableArray *subArr = [NSMutableArray arrayWithCapacity:numberOfItems];
        for (NSInteger item = 0; item &lt; numberOfItems; item++){
            NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section];
            UICollectionViewLayoutAttributes *attributes = [self layoutAttributesForItemAtIndexPath:indexPath];
            [subArr addObject:attributes];
        }
        if(maxNumberOfItems &lt; numberOfItems){
            maxNumberOfItems = numberOfItems;
        }
        //添加到二维数组
        [layoutInfoArr addObject:[subArr copy]];
    }
    //存储布局信息
    self.layoutInfoArr = [layoutInfoArr copy];
    //保存内容尺寸
    self.contentSize = CGSizeMake(maxNumberOfItems*(self.itemSize.width+self.interitemSpacing)+self.interitemSpacing, numberOfSections*(self.itemSize.height+self.lineSpacing)+self.lineSpacing);
}
</code></pre>

<p>在上面的代码中，我们看到了<code>UICollectionViewLayoutAttributes</code>这个类，这个类其实专门用来存储视图的内容，例如frame、size、apha、hiden等等，layout最后会拿着这些frame设置给对应的视图。
而上面代码中，获取<code>UICollectionViewLayoutAttributes</code>是通过<code>layoutAttributesForItemAtIndexPath:</code>方法</p>

<pre><code>- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath{
    UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
    //每一组cell为一行
    attributes.frame = CGRectMake((self.itemSize.width+self.interitemSpacing)*indexPath.row+self.interitemSpacing, (self.itemSize.height+self.lineSpacing)*indexPath.section+self.lineSpacing, self.itemSize.width, self.itemSize.height);
    return attributes;
}
</code></pre>

<p>在这个方法中，<code>itemSize</code>是cell的大小，<code>interitemSpacing</code>是cell与cell之间的间距，<code>lineSpacing</code>是行距。</p>

<h3>随后，覆写collectionViewContentSize</h3>

<p>collectionViewContentSize返回内容尺寸给UICollectionView。注意这个方法返回的尺寸是给UICollectionView这个继承于<code>UIScrollView</code>的视图作为<code>contentSize</code>，不是UICollectionView的视图尺寸。正是因为这一点，我们自定义layout如果想让它只能横向滑动，只需要将这个<code>size.height</code>设置成<code>collectionView.height</code>就行了。
这个方法会多次调用，所以最好是在prepareLayout里就计算好。
在BGGrideLayout类中，我们只需要返回前面计算好的内容尺寸就行了。</p>

<pre><code>- (CGSize)collectionViewContentSize{
    return self.contentSize;
}
</code></pre>

<h3>最后，覆写layoutAttributesForElementsInRect:方法</h3>

<p>此方法需要返回一组UICollectionViewLayoutAttributes类型对象。它代表着在这个指定的区域中，我们需要显示<code>cell</code>、<code>Supplementary View</code>和<code>Decoration View</code>中哪些视图，而这些视图的属性则保存UICollectionViewLayoutAttributes中。
此方法会多次调用，为了更好的性能，在这个方法当中，我们使用的UICollectionViewLayoutAttributes最好是在prepareLayout已经布局好的信息。</p>

<p>在BGGrideLayout中，我们遍历二维数组，找出了与指定区域有交接的UICollectionViewLayoutAttributes对象放到一个数组中，然后返回。</p>

<pre><code>- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect{
    NSMutableArray *layoutAttributesArr = [NSMutableArray array];
    [self.layoutInfoArr enumerateObjectsUsingBlock:^(NSArray *array, NSUInteger i, BOOL * _Nonnull stop) {
        [array enumerateObjectsUsingBlock:^(UICollectionViewLayoutAttributes *obj, NSUInteger idx, BOOL * _Nonnull stop) {
            if(CGRectIntersectsRect(obj.frame, rect)) {
                [layoutAttributesArr addObject:obj];
            }
        }];
    }];
    return layoutAttributesArr;
}
</code></pre>

<p>到这里，我们的BGGrideLayout已经写好了，使用部分的代码，请直接查看<a href="https://github.com/liuchungui/BGCustomLayoutCollectionViewDemo">BGCustomLayoutCollectionViewDemo</a>中ViewController里面的代码就行了。</p>

<p>效果：</p>

<p><img src="http://ww4.sinaimg.cn/large/7746cd07jw1exqk0a7ofyg208j0fr7wh.gif" alt="Demo" /></p>

<h2>参考</h2>

<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/Introduction/Introduction.html">Collection View Programming Guide for iOS</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionView之介绍使用篇]]></title>
    <link href="http://www.liuchungui.com/blog/2015/11/02/uicollectionviewzhi-jie-shao-shi-yong-pian/"/>
    <updated>2015-11-02T00:29:12+08:00</updated>
    <id>http://www.liuchungui.com/blog/2015/11/02/uicollectionviewzhi-jie-shao-shi-yong-pian</id>
    <content type="html"><![CDATA[<p>实现垂直方向的单列表来说，使用UITableView足以；若是需要构建横向滑动列表、gridView等直线型布局，则使用UICollectionView+UICollectionViewFlowLayout搭建最合适；更复杂的布局，则可以使用UICollectionView+自定义Layout来实现。</p>

<p>而这篇博客就来介绍一下UICollectionView。</p>

<p>首先，来了解一下UICollectionView工作流程：</p>

<p><img src="http://ww3.sinaimg.cn/large/7746cd07jw1exjnjqrju5j20x00qk76h.jpg" alt="" /></p>

<p>当UICollectionView显示内容时，先从数据源获取cell，然后交给UICollectionView。再从UICollectionViewLayout获取对应的layout attributes(布局属性)。最后，根据每个cell对应的layout attributes(布局属性)来对cell进行布局，生成了最终的界面。而用户交互的时候，都是通过Delegate来进行交互。当然，上面只是布局cell，但是UICollectionView内部还有Supplementary View和Decoration View，也可以对其进行布局。</p>

<p>上面，我们了解了UICollectionView的工作流程，我们将UICollectionView分成视图、数据源和代理方法、UICollectionViewLayout三块来介绍。</p>

<!-- more -->


<h2>一、视图</h2>

<p>UICollectionView上面显示内容的视图有三种Cell视图、Supplementary View和Decoration View。</p>

<h4>Cell视图</h4>

<p>CollectionView中主要的内容都是由它展示的，它是从数据源对象获取的。</p>

<h4>Supplementary View</h4>

<p>它展示了每一组当中的信息，与cell类似，它是从数据源方法当中获取的，但是与cell不同的是，它并不是强制需要的。例如flow layout当中的headers和footers就是可选的Supplementary View。</p>

<h4>Decoration View</h4>

<p>这个视图是一个装饰视图，它没有什么功能性，它不跟数据源有任何关系，它完全属于layout对象。</p>

<h2>二、数据源和代理方法</h2>

<h4>1、注册cell或者Supplementary View使其重用</h4>

<p>在使用数据源返回cell或者Supplementary View给collectionView之前，我们必须先要注册，用来进行重用。</p>

<ul>
<li>registerClass: forCellWithReuseIdentifier:</li>
<li>registerNib: forCellWithReuseIdentifier:</li>
<li>registerClass: forSupplementaryViewOfKind: withReuseIdentifier:</li>
<li>registerNib: forSupplementaryViewOfKind: withReuseIdentifier:</li>
</ul>


<p> 显而易见，前面两个方法是注册cell，后两个方法注册Supplementary View。其中，注册的方式有两种，第一种是直接注册class，它重用的时候会调用[[UICollectionView alloc] init]这样的初始化方法创建cell；另外一种是注册nib，它会自动加载nib文件。</p>

<p> 注册的之后，我们如何重用？       <br/>
 在数据源方法当中返回<code>cell</code>或者<code>Supplementary view</code>的方法当中通过<code>dequeueReusableCellWithReuseIdentifier:forIndexPath:</code> 或者 <code>dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:</code>方法获取cell或者Supplementary View。</p>

<p>示例代码：
<code>objc
- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath{
    CollectionViewCell *cell = (CollectionViewCell *)[collectionView dequeueReusableCellWithReuseIdentifier:CellReuseIdentify forIndexPath:indexPath];
    cell.backgroundColor = [UIColor lightGrayColor];
    cell.textLabel.text = [NSString stringWithFormat:@"(%zd,%zd)", indexPath.section, indexPath.row];
    return cell;
}
</code></p>

<h4>2、数据源方法</h4>

<p> 数据源方法与UITableView类似，主要有：</p>

<ul>
<li>numberOfSectionsInCollectionView:</li>
<li>collectionView: numberOfItemsInSection:</li>
<li>collectionView: cellForItemAtIndexPath:</li>
<li>collectionView: viewForSupplementaryElementOfKind: atIndexPath:</li>
</ul>


<p>与UITableView不同的是多加了返回Supplementary view数据源方法。</p>

<h4>3、代理方法</h4>

<p>数据源为UICollectionView提供数据相关的内容，而代理则主要负责用户交互、与数据无关的视图外形。主要分成两部分：</p>

<p>1、通过调用代理方法，管理视图的选中、高亮</p>

<ul>
<li>collectionView:shouldDeselectItemAtIndexPath:</li>
<li>collectionView:didSelectItemAtIndexPath:</li>
<li>collectionView:didDeselectItemAtIndexPath:</li>
<li>collectionView:shouldHighlightItemAtIndexPath:</li>
<li>collectionView:didHighlightItemAtIndexPath:</li>
<li>collectionView:didUnhighlightItemAtIndexPath:</li>
</ul>


<p> 2、长按cell，显示编辑菜单
 与UITableView不同，用户长按cell时，UICollectionView可以显示编辑菜单。这个编辑菜单可以用来剪切、复制和粘贴cell。不过，要显示这个编辑菜单需要满足下面几个条件：</p>

<ul>
<li>代理对象必须实现下面三个方法：     <br/>
<code>collectionView:shouldShowMenuForItemAtIndexPath:</code>   <code>collectionView:canPerformAction:forItemAtIndexPath:withSender:</code>   <code>collectionView:performAction:forItemAtIndexPath:withSender:</code></li>
<li>对于指定要编辑的cell，<code>collectionView:shouldShowMenuForItemAtIndexPath:</code>方法需要返回<code>YES</code></li>
<li><p><code>collectionView:canPerformAction:forItemAtIndexPath:withSender:</code> 方法中，对于剪切、复制、粘贴三种action至少有一个返回YES。其实，编辑菜单是有很多种action的，但是对于UICollectionView来说，它仅仅支持的剪切、复制、粘贴三个，所以说这个代理方法至少支持这三种的一种。  <br/>
剪切、复制、粘贴的方法名是：   <br/>
<code>cut:</code>   <br/>
<code>copy:</code>   <br/>
<code>paste:</code></p>

<p>当上面的条件都满足了，用户就可以长按cell显示出编辑菜单，然后选择对应的action，从而就会回调delegate的collectionView:performAction:forItemAtIndexPath:withSender: 方法去做对应的事情。</p></li>
</ul>


<p>当我们想控制编辑菜单仅仅显示复制和粘贴时，我们就可以在<code>collectionView:canPerformAction:forItemAtIndexPath:withSender:</code>方法中进行操作，具体请见下面代码：</p>

<pre><code class="objc">- (BOOL)collectionView:(UICollectionView *)collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender{
    if ([NSStringFromSelector(action) isEqualToString:@"copy:"]        || [NSStringFromSelector(action) isEqualToString:@"paste:"])        return YES;    return NO;
}
</code></pre>

<h2>三、UICollectionViewLayout</h2>

<p><code>UICollectionViewLayout</code>是通过<code>UICollectionViewLayoutAttributes</code>类来管理<code>cell</code>、<code>Supplementary View</code>和<code>Decoration View</code>的<code>位置</code>、<code>transform</code>、<code>alpha</code>、<code>hidden</code>等等。   <br/>
UICollectionViewLayout这个类只是一个基类，我们给UICollectionView使用的都是它的<code>子类</code>。系统为我们提供了一个最常用的layout为<code>UICollectionViewFlowLayout</code>，我们可以使用它制作<code>grid view</code>。当UICollectionViewLayout满足不了我们的需求时，我们可以<code>子类化UICollectionViewLayout</code>或者<code>自定义layout</code>，这个内容放到我下一篇当中。</p>

<h4>UICollectionViewFlowLayout</h4>

<p>使用UICollectionViewFlowLayout之前，我们来了解它内部常用的属性：</p>

<pre><code>//同一组当中，垂直方向：行与行之间的间距；水平方向：列与列之间的间距
@property (nonatomic) CGFloat minimumLineSpacing; 
//垂直方向：同一行中的cell之间的间距；水平方向：同一列中，cell与cell之间的间距
@property (nonatomic) CGFloat minimumInteritemSpacing;
//每个cell统一尺寸
@property (nonatomic) CGSize itemSize;
//滑动反向，默认滑动方向是垂直方向滑动
@property (nonatomic) UICollectionViewScrollDirection scrollDirection; 
//每一组头视图的尺寸。如果是垂直方向滑动，则只有高起作用；如果是水平方向滑动，则只有宽起作用。
@property (nonatomic) CGSize headerReferenceSize;
//每一组尾部视图的尺寸。如果是垂直方向滑动，则只有高起作用；如果是水平方向滑动，则只有宽起作用。
@property (nonatomic) CGSize footerReferenceSize;
//每一组的内容缩进
@property (nonatomic) UIEdgeInsets sectionInset;
</code></pre>

<p>注意：UICollectionViewFlowLayout内部的属性都是用来统一设置，若是统一设置无法满足需求，可以实现<code>UICollectionViewDelegateFlowLayout</code>代理方法，进行对应的设置。而后面内容我都以UICollectionViewFlowLayout的属性来叙述，请自行参照修改。</p>

<p>UICollectionViewFlowLayout在纵向滑动与横向滑动时，布局是不太一样的。</p>

<p align="center" >
  <img src="http://ww1.sinaimg.cn/large/7746cd07jw1exmpk8hs66j20ea0fcabe.jpg" width=257 height = 274>
  <img src="http://ww3.sinaimg.cn/large/7746cd07jw1exmq7ebjo2j20es0cujsp.jpg" width=266 height = 231>
</p>


<p>由上图就可以看出来，UICollectionViewFlowLayout在布局时，会根据scrollDirection的值不同而产生不同的布局。</p>

<ul>
<li><p>垂直方向滑动：</p>

<ul>
<li>Cell布局：UICollectionView的内容宽度与本身视图的宽度相等，并且是固定的。会根据<code>sectionInset左右缩进</code>、<code>itemSize的宽度</code>、<code>minimumInteritemSpacing</code>三个值来计算每一行cell数量。   <br/>
具体计算公式是:   <br/>
<code>  
cellCount = (CollectionViewContentWidth-sectionInset.left-sectionInset.right+minimumInteritemSpacing)/(itemSize.width+minimumInteritemSpacing)      
</code>
<code>CollectionViewContentWidth</code>是UICollectionView的内容宽度，计算出来的<code>cellCount</code>进行四舍五入成一个整数就是<code>每一行cell的数量</code>。  <br/>
而每个cell之间实际的间隔值则是:  <br/>
<code>realInteritemSpacing = (CollectionViewContentWidth-sectionInset.left-sectionInset.right-cellCount*itemSize.width)/(cellCount-1)</code>  <br/>
当每个cell大小确定、每一行cell的个数确定、每个cell之间的间距确定之后，UICollectionViewFlowLayout就可以计算出每一行cell的frame了。  <br/>
而如果同一组cell的个数，在水平方向的一行放不下去，则就会放入第二行，而这第二行的cell在垂直方向与第一行的cell相隔<code>minimumLineSpacing</code>。这样又确定了行与行之间的间距，那么这一组cell的布局就可以确定了。</li>
<li>头视图与尾部视图：根据headerReferenceSize和footerReferenceSize中的高来确定头部和尾部视图的高，它其实就是两个不同类型的Supplementary View。</li>
</ul>
</li>
<li><p>水平方向滑动：</p>

<ul>
<li>Cell布局：水平方向的滑动内容的高与本身视图的高是相等的，并且是固定的。它的cell是从<code>上到下进行布局</code>的。会根据<code>sectionInset上下缩进</code>、<code>itemSize的高度</code>、<code>minimumInteritemSpacing</code>三个值来计算每一列放多少个cell，具体计算公式可以参照垂直方向滑动的公式。之后的逻辑和垂直方向滑动时一样，只是minimumLineSpacing现在是代表列与列之间的间距。</li>
<li>头视图与尾部视图：根据headerReferenceSize和footerReferenceSize中的宽来确定头部和尾部视图的宽。</li>
</ul>
</li>
</ul>


<p>相关使用UICollectionViewFlowLayout代码:<a href="https://github.com/liuchungui/UICollectionViewDemo">UICollectionViewDemo</a></p>

<h2>参考</h2>

<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/Introduction/Introduction.html">Collection View Programming Guide for iOS</a>   <br/>
<a href="http://www.onevcat.com/2012/06/introducing-collection-views/">WWDC 2012 Session笔记——205 Introducing Collection Views</a></p>
]]></content>
  </entry>
  
</feed>
