<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | liuchungui's Blog]]></title>
  <link href="http://liuchungui.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://liuchungui.github.io/"/>
  <updated>2015-11-24T00:40:09+08:00</updated>
  <id>http://liuchungui.github.io/</id>
  <author>
    <name><![CDATA[刘春桂]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UICollectionView动画]]></title>
    <link href="http://liuchungui.github.io/blog/2015/11/24/uicollectionviewdong-hua/"/>
    <updated>2015-11-24T00:00:26+08:00</updated>
    <id>http://liuchungui.github.io/blog/2015/11/24/uicollectionviewdong-hua</id>
    <content type="html"><![CDATA[<h2>一、简单使用</h2>

<p>UICollectionView更新事件有四种分别是<code>插入</code>、<code>删除</code>、<code>刷新</code>、<code>移动</code>，
api使用起来和UITableView类似，具体可以自己在代码中找，如果需要执行多个更新事件，可以放到performBatchUpdates中的updates闭包中作为一组动画，然后全部执行完之后通过completion调回。</p>

<pre><code class="swift">    collectionView.performBatchUpdates({ () -&gt; Void in
                collectionView.insertItemsAtIndexPaths(insertIndexPaths)
                collectionView.moveItemAtIndexPath(currentIndexPath, toIndexPath: toIndexPath)
                }, completion: { (isFinish) -&gt; Void in
            })
</code></pre>

<h2>二、UICollectionView动画</h2>

<p>四种不同的更新事件，系统默认会带有动画，不过是比较简单的。我们可以自定义layout或者继承flowLayout，在内部实现我们自己想要的动画。下面，我们来说说动画的流程，以及系统默认的四种动画内部是如何的，并且通过代码来修改达到自己想要的动画。</p>

<!-- more -->


<h4>CollectionView动画流程</h4>

<p>当我们在外部调用CollectionView相关的api去<code>插入</code>、<code>删除</code>、<code>刷新</code>、<code>移动</code>cell时，首先会通过layout中的<code>layoutAttributesForElementsInRect</code>方法获取更新以后的布局信息，然后通过<code>prepareForCollectionViewUpdates</code>方法来通知layout哪些内容将会发生改变。之后，通过调用layout中的<code>initialLayoutAttributesForAppearingItemAtIndexPath</code>、<code>finalLayoutAttributesForDisappearingItemAtIndexPath</code>方法获取对应indexPath的<code>刚出现时最初布局属性</code>和<code>消失时最终布局属性</code>。而后形成两个动画过程分别是<code>刚出现时最初布局-&gt;更新后布局的出现动画</code>和<code>更新前布局-&gt;消失时最终布局的消失动画</code>，而collectionView中'插入'、'删除'、'刷新'和'移动'动画都是基于这两个动画组合形成的。最后，等这一系列动画执行完之后，最后会调用layout中<code>finalizeCollectionViewUpdates</code>方法，这个方法仍然放在动画块中，我们可以在这个方法当中添加额外的动画。</p>

<p>从上面流程可以看出，在更新的时候，由于<code>更新前布局</code>和<code>更新后布局</code>都是在更新动画前已经设置好了，我们不能去胡乱更改布局，所以我们只能通过<code>initialLayoutAttributesForAppearingItemAtIndexPath</code>和<code>finalLayoutAttributesForDisappearingItemAtIndexPath</code>两个方法来更改<code>刚出现时最初布局属性</code>和<code>消失时最终布局属性</code>，即我们只能更改<code>出现动画的起点</code>和<code>消失动画的终点</code>。</p>

<p>为了更方面的下面说明，引申出两个名词：</p>

<ul>
<li>出现动画：initialLayoutAttributesForAppearingItemAtIndexPath获取对应indexPath的<code>刚出现时最初布局</code>->更新后布局变化过程</li>
<li>消失动画：更新之前的布局->finalLayoutAttributesForDisappearingItemAtIndexPath方法获取对应indexPath的<code>消失时最终布局</code>的变化过程</li>
</ul>


<p>注意，出现动画和消失动画针对的是一个cell单元。</p>

<p>下面我们通过代码示例来实现插入、删除、刷新、移动动画。
代码示例工程：<a href="https://github.com/liuchungui/UICollectionViewAnimationDemo">UICollectionViewAnimationDemo</a></p>

<p>在这个Demo工程中有一个<code>BGSelectImageLayout</code>，它是CollectionView的layout，它的布局方式是水平横向滑动，并且只有一组，每一个普通的cell大小都是<code>itemSize</code>，而选中的cell则宽度是<code>itemSize*2</code>。</p>

<h4>插入动画：</h4>

<p>在当前的布局下，每插入一个cell时，都会影响它后面所有cell布局变化。      <br/>
例如CollectionView有一行三个cell，为了更好的说明将indexPath是(0,0),(0,1),(0,2)标记为0，1，2。当在第1个位置插入一个cell时，如下图</p>

<p><img src="http://ww2.sinaimg.cn/large/7746cd07jw1eyba1ih4nvj20re0fs75l.jpg" alt="" /></p>

<p>而在这个插入过程中，视觉上会有三个动画过程。new插入到位置1为<code>过程1</code>，1移动一个单位到2为<code>过程2</code>，2移动一个单位到一个新的位置3为<code>过程3</code>，如下图：</p>

<p><img src="http://ww3.sinaimg.cn/large/7746cd07jw1eyba58t45gj20yc0g6760.jpg" alt="" /></p>

<p>虽然视觉上只有三个动画过程，但其实有五个动画。其中，过程1是1位置的<code>出现动画</code>；过程2是1位置的<code>消失动画</code>和2位置的<code>出现动画</code>重合而成；过程3是2位置的<code>消失动画</code>和3位置的<code>出现动画</code>。</p>

<p>其中值得注意的三点，一是除了最后一个，前面的cell消失动画与它后面cell出现动画重合，这样看起来就是当前位置的cell向后平移了一个位置；二是最后一个cell只有出现动画，没有消失动画，整个过程<code>出现动画会多一个</code>；三是插入的cell的出现动画是默认是alpha从0到1的淡入效果。</p>

<p>在代码中，想获得一个插入的cell从小变大的出现效果和其它cell整体向后移动一个位置的动画效果，可以如下实现：</p>

<pre><code>    override func initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
        let attributes = super.initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
        if self.insertIndexPathArr.contains(itemIndexPath) {
            attributes?.transform = CGAffineTransformMakeScale(0.0, 0.0)
            attributes?.alpha = 0
        }
        else {
            //设置为前一个item的frame
            attributes?.frame = self.currentFrameWithIndexPath(NSIndexPath(forRow: itemIndexPath.row-1, inSection: itemIndexPath.section))
        }
        return attributes
}
override func finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
         let attributes = super.finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
         attributes?.frame = self.currentFrameWithIndexPath(NSIndexPath(forRow: itemIndexPath.row+1, inSection: itemIndexPath.section))
         return attributes
}
</code></pre>

<p>这里为了看到效果，我在模拟器的Debug模式下勾选了Slow Animations调慢了动画:
<img src="http://ww3.sinaimg.cn/large/7746cd07jw1eyaa2ommv4g208j0frab5.gif" alt="" /></p>

<h4>删除动画：</h4>

<p>在上面的位置1插入一个cell后，cell的数量变成了4个，分别是0、1、2、3，它们对应的indexPath为(0,0)、(0,1)、(0,2)、(0,3)。当要删除位置1的cell时，与插入类似，系统默认也会有三个动画过程，如下图：</p>

<p><img src="http://ww3.sinaimg.cn/large/7746cd07jw1eybbqnkm4cj20xo0dita5.jpg" alt="" /></p>

<p>其中，动画过程1是在位置1执行一个消失动画；过程2是位置1的出现动画和位置2的消失动画重合而成；过程3是位置2的出现动画和位置3的消失动画重合而成。</p>

<p><strong>需要注意的是</strong>，一是与插入不同，重合后的效果是cell向前平移了一个位置；二是最后一个位置只有消失动画没有出现动画，整个过程消失动画数会多一个；三是删除的cell的出现动画默认是从1到0的淡出效果。</p>

<p>在代码中，实现一个与插入相对应的动画，即删除的cell从大到小的淡出效果和其它cell整体向前移动一个位置的效果，可以如下实现：</p>

<pre><code>override func initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
    let attributes = super.initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
    attributes?.frame = self.currentFrameWithIndexPath(NSIndexPath(forRow: itemIndexPath.row+1, inSection: itemIndexPath.section))
    return attributes
}
override func finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
        let attributes = super.finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
    if self.deleteIndexPathArr.contains(itemIndexPath) {
        //这里写成缩放成(0，0)直接就不见了
        attributes?.transform = CGAffineTransformMakeScale(0.1, 0.1)
        attributes?.alpha = 0.0
    }
    else {
        attributes?.frame = self.currentFrameWithIndexPath(NSIndexPath(forRow: itemIndexPath.row-1, inSection: itemIndexPath.section))
    }
    return attributes
}
</code></pre>

<p>效果如下：</p>

<p><img src="http://ww2.sinaimg.cn/large/7746cd07jw1eyaqorep4rg208j0g9wgw.gif" alt="" /></p>

<h4>刷新动画：</h4>

<p>在官方的解释中，刷新是先删除然后插入。其实它就是先执行所有cell的消失动画；在此之后，它又会执行所有cell的出现动画。
在系统当中，需要注意的是默认出现动画是一个alpha从0到1的淡入效果，而消失动画则是alpha从1到0的淡入效果；与插入动画和删除动画不同的是，刷新动画会成对存在，即消失动画与出现动画数量相等。</p>

<p>在这里，实现一个点击某个cell时，当前选中的cell变大的效果，而它旁边的cell被推开的动画效果。在这里我不需要淡入和淡出效果，所以修改了消失时alpha为1.0，代码如下：</p>

<pre><code>override func initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
    let attributes = super.initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
    attributes?.frame = self.lastFrameWithIndexPath(itemIndexPath)
    return attributes
}
override func finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
    let attributes = super.finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
    //注意，这里alpha设置为不透明，系统默认返回是0，即一个淡出的效果
    attributes?.alpha = 1.0
    attributes?.frame = self.currentFrameWithIndexPath(itemIndexPath)
    return attributes
}
</code></pre>

<p>效果如下：</p>

<p><img src="http://ww2.sinaimg.cn/large/7746cd07jw1eyb04xye32g208j0g9755.gif" alt="" /></p>

<h4>移动动画：</h4>

<p>移动一个cell到另一个位置时，会引起当前cell到目标位置之间所有cell布局发生变化，从而形成一系列的动画。在这个动画过程中，每个indexPath都会有一个出现动画和一个消失动画。</p>

<p>例如，在系统默认情况下，0位置cell移动到2位置cell的时候，我们会看到三个动画过程，如下图：</p>

<p><img src="http://ww1.sinaimg.cn/large/7746cd07jw1eyazemzgkzj20qa0bqt9u.jpg" alt="" /></p>

<p>但是，其实它内部执行了六个动画，只是其中两两之间动画重合了而已。其中动画过程1是1位置的消失动画和0位置出现动画重合；动画过程2是0位置的消失动画和2位置的出现动画重合；动画过程3是2位置的消失动画和1位置的出现动画重合。</p>

<p><strong>其中值得注意的有两点：</strong>   <br/>
1、消失动画和出现动画数量相等    <br/>
2、动画的重合与刷新动画不同，与插入和删除动画类似，它们不同位置之间的消失动画与出现动画重合。</p>

<p>在这里，实现一个移动cell时旋转180°到目标位置效果，实现如下：</p>

<pre><code> override func initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
    let attributes = super.initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
    if itemIndexPath == self.afterMoveIndexPath {
        //afterMoveIndexPath的消失动画和beforeMoveIndexPath的出现动画重合
        //init是设置起点，而final设置终点，理论是不重合的
        attributes?.transform3D = CATransform3DMakeRotation(-1*CGFloat(M_PI), 0, 0, -1)
    }
    return attributes
}
override func finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes? {
    let attributes = super.finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath)?.copy() as? UICollectionViewLayoutAttributes
    if self.beforeMoveIndexPath == itemIndexPath {
        //afterMoveIndexPath的消失动画和beforeMoveIndexPath的出现动画重合，设置他们旋转的角度一样，方向相反
        attributes?.transform3D = CATransform3DMakeRotation(-1*CGFloat(M_PI), 0, 0, -1)
    }
    return attributes
}
</code></pre>

<p>效果如下：</p>

<p><img src="http://ww1.sinaimg.cn/large/7746cd07jw1eyb0375fz7g208j0g9go4.gif" alt="" /></p>

<p>了解了UICollectionView的动画流程，以及默认系统的四种动画的执行规则，若是跟着我一样修改了系统默认的动画，这个时候应该对CollectionView的动画也了解了差不多了。</p>

<h2>总结：</h2>

<p>1、CollectionView更新时，执行动画的时候会访问layout中哪些api，整个流程是如何形成的        <br/>
2、修改CollectionView动画就是修改出现动画的起点和消失动画的终点，即layout当中的initialLayoutAttributesForAppearingItemAtIndexPath和finalLayoutAttributesForDisappearingItemAtIndexPath方法进行修改。     <br/>
3、插入、删除、刷新、移动内部执行哪些动画，我们如何去修改。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionView之介绍使用篇]]></title>
    <link href="http://liuchungui.github.io/blog/2015/11/02/uicollectionviewzhi-jie-shao-shi-yong-pian/"/>
    <updated>2015-11-02T00:29:12+08:00</updated>
    <id>http://liuchungui.github.io/blog/2015/11/02/uicollectionviewzhi-jie-shao-shi-yong-pian</id>
    <content type="html"><![CDATA[<p>实现垂直方向的单列表来说，使用UITableView足以；若是需要构建横向滑动列表、gridView等直线型布局，则使用UICollectionView+UICollectionViewFlowLayout搭建最合适；更复杂的布局，则可以使用UICollectionView+自定义Layout来实现。</p>

<p>而这篇博客就来介绍一下UICollectionView。</p>

<p>首先，来了解一下UICollectionView工作流程：</p>

<p><img src="http://ww3.sinaimg.cn/large/7746cd07jw1exjnjqrju5j20x00qk76h.jpg" alt="" /></p>

<p>当UICollectionView显示内容时，先从数据源获取cell，然后交给UICollectionView。再从UICollectionViewLayout获取对应的layout attributes(布局属性)。最后，根据每个cell对应的layout attributes(布局属性)来对cell进行布局，生成了最终的界面。而用户交互的时候，都是通过Delegate来进行交互。当然，上面只是布局cell，但是UICollectionView内部还有Supplementary View和Decoration View，也可以对其进行布局。</p>

<p>上面，我们了解了UICollectionView的工作流程，我们将UICollectionView分成视图、数据源和代理方法、UICollectionViewLayout三块来介绍。</p>

<!-- more -->


<h2>一、视图</h2>

<p>UICollectionView上面显示内容的视图有三种Cell视图、Supplementary View和Decoration View。</p>

<h4>Cell视图</h4>

<p>CollectionView中主要的内容都是由它展示的，它是从数据源对象获取的。</p>

<h4>Supplementary View</h4>

<p>它展示了每一组当中的信息，与cell类似，它是从数据源方法当中获取的，但是与cell不同的是，它并不是强制需要的。例如flow layout当中的headers和footers就是可选的Supplementary View。</p>

<h4>Decoration View</h4>

<p>这个视图是一个装饰视图，它没有什么功能性，它不跟数据源有任何关系，它完全属于layout对象。</p>

<h2>二、数据源和代理方法</h2>

<h4>1、注册cell或者Supplementary View使其重用</h4>

<p>在使用数据源返回cell或者Supplementary View给collectionView之前，我们必须先要注册，用来进行重用。</p>

<ul>
<li>registerClass: forCellWithReuseIdentifier:</li>
<li>registerNib: forCellWithReuseIdentifier:</li>
<li>registerClass: forSupplementaryViewOfKind: withReuseIdentifier:</li>
<li>registerNib: forSupplementaryViewOfKind: withReuseIdentifier:</li>
</ul>


<p> 显而易见，前面两个方法是注册cell，后两个方法注册Supplementary View。其中，注册的方式有两种，第一种是直接注册class，它重用的时候会调用[[UICollectionView alloc] init]这样的初始化方法创建cell；另外一种是注册nib，它会自动加载nib文件。</p>

<p> 注册的之后，我们如何重用？       <br/>
 在数据源方法当中返回<code>cell</code>或者<code>Supplementary view</code>的方法当中通过<code>dequeueReusableCellWithReuseIdentifier:forIndexPath:</code> 或者 <code>dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:</code>方法获取cell或者Supplementary View。</p>

<p>示例代码：
<code>objc
- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath{
    CollectionViewCell *cell = (CollectionViewCell *)[collectionView dequeueReusableCellWithReuseIdentifier:CellReuseIdentify forIndexPath:indexPath];
    cell.backgroundColor = [UIColor lightGrayColor];
    cell.textLabel.text = [NSString stringWithFormat:@"(%zd,%zd)", indexPath.section, indexPath.row];
    return cell;
}
</code></p>

<h4>2、数据源方法</h4>

<p> 数据源方法与UITableView类似，主要有：</p>

<ul>
<li>numberOfSectionsInCollectionView:</li>
<li>collectionView: numberOfItemsInSection:</li>
<li>collectionView: cellForItemAtIndexPath:</li>
<li>collectionView: viewForSupplementaryElementOfKind: atIndexPath:</li>
</ul>


<p>与UITableView不同的是多加了返回Supplementary view数据源方法。</p>

<h4>3、代理方法</h4>

<p>数据源为UICollectionView提供数据相关的内容，而代理则主要负责用户交互、与数据无关的视图外形。主要分成两部分：</p>

<p>1、通过调用代理方法，管理视图的选中、高亮</p>

<ul>
<li>collectionView:shouldDeselectItemAtIndexPath:</li>
<li>collectionView:didSelectItemAtIndexPath:</li>
<li>collectionView:didDeselectItemAtIndexPath:</li>
<li>collectionView:shouldHighlightItemAtIndexPath:</li>
<li>collectionView:didHighlightItemAtIndexPath:</li>
<li>collectionView:didUnhighlightItemAtIndexPath:</li>
</ul>


<p> 2、长按cell，显示编辑菜单
 与UITableView不同，用户长按cell时，UICollectionView可以显示编辑菜单。这个编辑菜单可以用来剪切、复制和粘贴cell。不过，要显示这个编辑菜单需要满足下面几个条件：</p>

<ul>
<li>代理对象必须实现下面三个方法：     <br/>
<code>collectionView:shouldShowMenuForItemAtIndexPath:</code>   <code>collectionView:canPerformAction:forItemAtIndexPath:withSender:</code>   <code>collectionView:performAction:forItemAtIndexPath:withSender:</code></li>
<li>对于指定要编辑的cell，<code>collectionView:shouldShowMenuForItemAtIndexPath:</code>方法需要返回<code>YES</code></li>
<li><p><code>collectionView:canPerformAction:forItemAtIndexPath:withSender:</code> 方法中，对于剪切、复制、粘贴三种action至少有一个返回YES。其实，编辑菜单是有很多种action的，但是对于UICollectionView来说，它仅仅支持的剪切、复制、粘贴三个，所以说这个代理方法至少支持这三种的一种。  <br/>
剪切、复制、粘贴的方法名是：   <br/>
<code>cut:</code>   <br/>
<code>copy:</code>   <br/>
<code>paste:</code></p>

<p>当上面的条件都满足了，用户就可以长按cell显示出编辑菜单，然后选择对应的action，从而就会回调delegate的collectionView:performAction:forItemAtIndexPath:withSender: 方法去做对应的事情。</p></li>
</ul>


<p>当我们想控制编辑菜单仅仅显示复制和粘贴时，我们就可以在<code>collectionView:canPerformAction:forItemAtIndexPath:withSender:</code>方法中进行操作，具体请见下面代码：</p>

<pre><code class="objc">- (BOOL)collectionView:(UICollectionView *)collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender{
    if ([NSStringFromSelector(action) isEqualToString:@"copy:"]        || [NSStringFromSelector(action) isEqualToString:@"paste:"])        return YES;    return NO;
}
</code></pre>

<h2>三、UICollectionViewLayout</h2>

<p><code>UICollectionViewLayout</code>是通过<code>UICollectionViewLayoutAttributes</code>类来管理<code>cell</code>、<code>Supplementary View</code>和<code>Decoration View</code>的<code>位置</code>、<code>transform</code>、<code>alpha</code>、<code>hidden</code>等等。   <br/>
UICollectionViewLayout这个类只是一个基类，我们给UICollectionView使用的都是它的<code>子类</code>。系统为我们提供了一个最常用的layout为<code>UICollectionViewFlowLayout</code>，我们可以使用它制作<code>grid view</code>。当UICollectionViewLayout满足不了我们的需求时，我们可以<code>子类化UICollectionViewLayout</code>或者<code>自定义layout</code>，这个内容放到我下一篇当中。</p>

<h4>UICollectionViewFlowLayout</h4>

<p>使用UICollectionViewFlowLayout之前，我们来了解它内部常用的属性：</p>

<pre><code>//同一组当中，垂直方向：行与行之间的间距；水平方向：列与列之间的间距
@property (nonatomic) CGFloat minimumLineSpacing; 
//垂直方向：同一行中的cell之间的间距；水平方向：同一列中，cell与cell之间的间距
@property (nonatomic) CGFloat minimumInteritemSpacing;
//每个cell统一尺寸
@property (nonatomic) CGSize itemSize;
//滑动反向，默认滑动方向是垂直方向滑动
@property (nonatomic) UICollectionViewScrollDirection scrollDirection; 
//每一组头视图的尺寸。如果是垂直方向滑动，则只有高起作用；如果是水平方向滑动，则只有宽起作用。
@property (nonatomic) CGSize headerReferenceSize;
//每一组尾部视图的尺寸。如果是垂直方向滑动，则只有高起作用；如果是水平方向滑动，则只有宽起作用。
@property (nonatomic) CGSize footerReferenceSize;
//每一组的内容缩进
@property (nonatomic) UIEdgeInsets sectionInset;
</code></pre>

<p>注意：UICollectionViewFlowLayout内部的属性都是用来统一设置，若是统一设置无法满足需求，可以实现<code>UICollectionViewDelegateFlowLayout</code>代理方法，进行对应的设置。而后面内容我都以UICollectionViewFlowLayout的属性来叙述，请自行参照修改。</p>

<p>UICollectionViewFlowLayout在纵向滑动与横向滑动时，布局是不太一样的。</p>

<p align="center" >
  <img src="http://ww1.sinaimg.cn/large/7746cd07jw1exmpk8hs66j20ea0fcabe.jpg" width=257 height = 274>
  <img src="http://ww3.sinaimg.cn/large/7746cd07jw1exmq7ebjo2j20es0cujsp.jpg" width=266 height = 231>
</p>


<p>由上图就可以看出来，UICollectionViewFlowLayout在布局时，会根据scrollDirection的值不同而产生不同的布局。</p>

<ul>
<li><p>垂直方向滑动：</p>

<ul>
<li>Cell布局：UICollectionView的内容宽度与本身视图的宽度相等，并且是固定的。会根据<code>sectionInset左右缩进</code>、<code>itemSize的宽度</code>、<code>minimumInteritemSpacing</code>三个值来计算每一行cell数量。   <br/>
具体计算公式是:   <br/>
<code>  
cellCount = (CollectionViewContentWidth-sectionInset.left-sectionInset.right+minimumInteritemSpacing)/(itemSize.width+minimumInteritemSpacing)      
</code>
<code>CollectionViewContentWidth</code>是UICollectionView的内容宽度，计算出来的<code>cellCount</code>进行四舍五入成一个整数就是<code>每一行cell的数量</code>。  <br/>
而每个cell之间实际的间隔值则是:  <br/>
<code>realInteritemSpacing = (CollectionViewContentWidth-sectionInset.left-sectionInset.right-cellCount*itemSize.width)/(cellCount-1)</code>  <br/>
当每个cell大小确定、每一行cell的个数确定、每个cell之间的间距确定之后，UICollectionViewFlowLayout就可以计算出每一行cell的frame了。  <br/>
而如果同一组cell的个数，在水平方向的一行放不下去，则就会放入第二行，而这第二行的cell在垂直方向与第一行的cell相隔<code>minimumLineSpacing</code>。这样又确定了行与行之间的间距，那么这一组cell的布局就可以确定了。</li>
<li>头视图与尾部视图：根据headerReferenceSize和footerReferenceSize中的高来确定头部和尾部视图的高，它其实就是两个不同类型的Supplementary View。</li>
</ul>
</li>
<li><p>水平方向滑动：</p>

<ul>
<li>Cell布局：水平方向的滑动内容的高与本身视图的高是相等的，并且是固定的。它的cell是从<code>上到下进行布局</code>的。会根据<code>sectionInset上下缩进</code>、<code>itemSize的高度</code>、<code>minimumInteritemSpacing</code>三个值来计算每一列放多少个cell，具体计算公式可以参照垂直方向滑动的公式。之后的逻辑和垂直方向滑动时一样，只是minimumLineSpacing现在是代表列与列之间的间距。</li>
<li>头视图与尾部视图：根据headerReferenceSize和footerReferenceSize中的宽来确定头部和尾部视图的宽。</li>
</ul>
</li>
</ul>


<p>相关使用UICollectionViewFlowLayout代码:<a href="https://github.com/liuchungui/UICollectionViewDemo">UICollectionViewDemo</a></p>

<h2>参考</h2>

<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/Introduction/Introduction.html">Collection View Programming Guide for iOS</a>   <br/>
<a href="http://www.onevcat.com/2012/06/introducing-collection-views/">WWDC 2012 Session笔记——205 Introducing Collection Views</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9之适配ATS]]></title>
    <link href="http://liuchungui.github.io/blog/2015/10/11/ios9zhi-gua-pei-ats/"/>
    <updated>2015-10-11T13:15:11+08:00</updated>
    <id>http://liuchungui.github.io/blog/2015/10/11/ios9zhi-gua-pei-ats</id>
    <content type="html"><![CDATA[<p>最近的iOS9系统出来了，而网络方面的ATS(App Transport Security)特性可以说每个人都要经历。而我这篇博客，就是结合我最近几天的经历，来谈谈从服务器到iOS客户端对ATS的适配。</p>

<h3>一、简单谈谈ATS(App Transport Security)</h3>

<p>ATS(App Transport Security)是为了提高App与服务器之间安全传输数据一个特性，这个特性从iOS9和OSX10.11开始出现，它默认需要满足以下几个条件：</p>

<ul>
<li>服务器TLS版本至少是1.2版本</li>
<li>连接加密只允许几种先进的加密</li>
<li>证书必须使用SHA256或者更好的哈希算法进行签名，要么是2048位或者更长的RSA密钥，要么就是256位或更长的ECC密钥</li>
</ul>


<p>如果想了解哪几种先进的加密是被允许的，详情请见官方文档<a href="https://developer.apple.com/library/mac/technotes/App-Transport-Security-Technote/">App Transport Security Technote</a></p>

<!-- more -->


<h3>二、搭建HTTPS服务器</h3>

<p>搭建HTTPS服务器有两种方式，一种是创建证书请求，然后到权威机构认证，随之配置到服务器；另外一种是自建证书，然后配置给服务器。第一种方式搭建的HTTPS服务器当然是最优的了，建立网站的话，直接就会被信任，而作为移动端app的服务器时，也不需要为ATS做过多的适配。虽然说权威的机构认证都是需要钱的，但是如今也不乏存在免费的第三方认证机构；第二种方式搭建的HTTPS服务器，对于网站来说完全不可行，用户打开时直接弹出一个警告提醒，说这是一个不受信任的网站，让用户是否继续，体验很差，而且让用户感觉网站不安全。对于移动端来说，在iOS9出现之前，这个没什么问题，但是在iOS9出来之后，第二种方式是通不过ATS特性，需要将NSAllowsArbitraryLoads设置为YES才行。所以，我推荐使用第一种方式搭建HTTPS服务器。   <br/>
下面，咱们来说说这两种方式都如何进行操作。</p>

<h5>第一种、使用CA机构认证的证书搭建HTTPS服务器</h5>

<p>1、创建证书请求，并提交给CA机构认证</p>

<pre><code>#生成私钥
openssl genrsa -des3 -out private.key 2048
#生成服务器的私钥，去除密钥口令 
openssl rsa -in private.key -out server.key
#生成证书请求
openssl req -new -key private.key -out server.csr
</code></pre>

<p>将生成server.csr提交给CA机构，CA机构对它进行签名之后，然后会生成签名后的根证书和服务器证书发送给你，这个时候的证书就是CA认证之后的证书。我们这里将根证书和服务器证书分别改名为ca.crt和serve.crt。</p>

<p>2、配置Apache服务器   <br/>
将ca.crt、server.key、server.crt上传到阿里云服务器，使用SSH登陆进入这三个文件的目录，执行下面命令</p>

<pre><code>mkdir ssl
cp server.crt /alidata/server/httpd/conf/ssl/server.crt
cp server.key /alidata/server/httpd/conf/ssl/server.key
cp demoCA/cacert.pem /alidata/server/httpd/conf/ssl/ca.crt
cp -r ssl /alidata/server/httpd/conf/
</code></pre>

<p>编辑<code>/alidata/server/httpd/conf/extra/httpd-ssl.conf</code>文件，找到SSLCertificateFile、SSLCertificateKeyFile、SSLCACertificatePath、SSLCACertificateFile进行修改</p>

<pre><code># 指定服务器证书位置
SSLCertificateFile "/alidata/server/httpd/conf/ssl/server.crt"
# 指定服务器证书key位置
SSLCertificateKeyFile "/alidata/server/httpd/conf/ssl/server.key"
# 证书目录
SSLCACertificatePath "/alidata/server/httpd/conf/ssl"
# 根证书位置
SSLCACertificateFile "/alidata/server/httpd/conf/ssl/ca.crt"
</code></pre>

<p>修改vhost配置<code>vim /alidata/server/httpd/conf/vhosts/phpwind.conf</code></p>

<pre><code>&lt;VirtualHost *:443&gt;
        SSLCertificateFile    /alidata/server/httpd/conf/ssl/server.crt
        SSLCertificateKeyFile /alidata/server/httpd/conf/ssl/server.key
        SSLCACertificatePath /alidata/server/httpd/conf/ssl
        SSLCACertificateFile /alidata/server/httpd/conf/ssl/ca.crt
        ServerName www.casetree.cn
        DocumentRoot /alidata/www
&lt;/VirtualHost&gt;
</code></pre>

<p>最后，重启Apache服务器，在浏览器输入网址查看是否配置成功。我这里是个人使用，申请的是免费的证书，我申请证书的网站是<a href="http://www.wosign.com/DVSSL/DV_KuaiSSL_Free.htm">沃通</a>。  <br/>
搭建的成果：<a href="https://www.casetree.cn">https://www.casetree.cn</a></p>

<h5>第二种、自建证书配置HTTPS服务器</h5>

<p>请查看我的上一篇<a href="http://www.liuchungui.com/blog/2015/09/25/zi-jian-zheng-shu-pei-zhi-httpsfu-wu-qi/">自建证书配置HTTPS服务器</a></p>

<h3>三、使用nscurl对服务器进行检测</h3>

<p>搭建完HTTPS服务器之后，可以使用nscurl命令来进行检测，查看建立的HTTPS服务器是否能通过ATS特性。</p>

<pre><code>nscurl --ats-diagnostics --verbose https://casetree.cn
</code></pre>

<p>如果HTTPS服务器能通过ATS特性，则上面所有测试案例都是PASS；如果某一项的Reuslt是FAIL，就找到ATS Dictionary来查看，就能知道HTTPS服务器不满足ATS哪个条件。
这里我前面碰到一个问题，就是自建证书的时候，通过此命令进行测试时，发现Result全是FAIL，而且在iOS的代码测试中也出现了一个很奇怪的现象，就是相同的代码，在iOS8.4请求数据完全正常，但是在iOS9上，直接是连接失败。最终发现，其实就是因为自建证书不受信任，是通不过ATS的，除非将NSAllowsArbitraryLoads设置为YES。</p>

<h3>四、iOS客户端</h3>

<p>在上面的第二大步骤当中，HTTPS服务器满足ATS默认的条件，而且SSL证书是通过权威的CA机构认证过的，那么我们在使用Xcode7开发的时候，对网络的适配什么都不用做，我们也能正常与服务器通信。但是，当我们对安全性有更高的要求时或者我们自建证书时，我们需要本地导入证书来进行验证。   <br/>
那么，如何本地导入证书进行验证呢？   <br/>
在这里先提一下，由于iOS客户端支持的证书是DER格式的，我们需要创建客户端证书。创建客户端证书，直接将服务端的CA根证书导出成DER格式就行。</p>

<pre><code>openssl  x509  -inform PEM  -outform DER -in ca.crt -out ca.cer
</code></pre>

<p>导入完证书之后，我们分别来说说使用NSURLSession和AFNetworking来进行本地验证。</p>

<h5>首先，来说说使用NSURLSession验证</h5>

<p>验证步骤如下：   <br/>
1、导入CA根证书到工程中，即我们创建的ca.cer   <br/>
2、获取trust object，通过SecCertificateCreateWithData方法读取导入的证书的数据生成一个证书对象，然后通过SecTrustSetAnchorCertificates
设置这个证书为trust object的信任根证书（trusted anchor)  <br/>
3、通过SecTrustEvaluate方法去验证trust object  <br/>
下面是主要OC实现代码，Demo工程我也放在github上了，有OC和Swift两种语言，下载Demo请点击<a href="https://github.com/liuchungui/HTTPSConnectDemo">HTTPSConnectDemo</a>。</p>

<pre><code class="objc">- (void)viewDidLoad {
    [super viewDidLoad];
    //导入客户端证书
    NSString *cerPath = [[NSBundle mainBundle] pathForResource:@"ca" ofType:@"cer"];
    NSData *data = [NSData dataWithContentsOfFile:cerPath];
    SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef) data);
    self.trustedCerArr = @[(__bridge_transfer id)certificate];

    //发送请求
    NSURL *testURL = [NSURL URLWithString:@"https://casetree.cn/web/test/demo.php"];
    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];
    NSURLSessionDataTask *task = [session dataTaskWithRequest:[NSURLRequest requestWithURL:testURL]];
    [task resume];
    // Do any additional setup after loading the view, typically from a nib.
}

#pragma mark - NSURLSessionDelegate
- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * __nullable credential))completionHandler{

    OSStatus err;
    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
    SecTrustResultType  trustResult = kSecTrustResultInvalid;
    NSURLCredential *credential = nil;

    //获取服务器的trust object
    SecTrustRef serverTrust = challenge.protectionSpace.serverTrust;

    //将读取的证书设置为serverTrust的根证书
    err = SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)self.trustedCerArr);

    if(err == noErr){
        //通过本地导入的证书来验证服务器的证书是否可信，如果将SecTrustSetAnchorCertificatesOnly设置为NO，则只要通过本地或者系统证书链任何一方认证就行
        err = SecTrustEvaluate(serverTrust, &amp;trustResult);
    }

    if (err == errSecSuccess &amp;&amp; (trustResult == kSecTrustResultProceed || trustResult == kSecTrustResultUnspecified)){
        //认证成功，则创建一个凭证返回给服务器
        disposition = NSURLSessionAuthChallengeUseCredential;
        credential = [NSURLCredential credentialForTrust:serverTrust];
    }
    else{
        disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;
    }

    //回调凭证，传递给服务器
    if(completionHandler){
        completionHandler(disposition, credential);
    }
}
</code></pre>

<p>注意：   <br/>
1、SecTrustSetAnchorCertificates方法会设置一个标示去屏蔽trust object对其它根证书的信任；如果你也想信任系统默认的根证书，请调用SecTrustSetAnchorCertificatesOnly方法，清空这个标示（设置为NO）
2、验证的方法不仅仅只有这一种，更多的验证方法，请参考<a href="https://developer.apple.com/library/ios/technotes/tn2232/_index.html#//apple_ref/doc/uid/DTS40012884-CH1-SECCUSTOMIZEAPIS">HTTPS Server Trust Evaluation</a></p>

<h5>下面，来谈谈AFNetworking是如何验证的，我们如何使用AFNetworking</h5>

<p>AFNetworking的证书验证工作是由AFSecurityPolicy来完成的，所以这里我们主要来了解一下AFSecurityPolicy。<strong>注意：我这里使用的是AFNetworking2.6.0，它跟2.5.0是有区别的。</strong>  <br/>
说到AFSecurityPolicy，我们必须要提到它三个重要的属性，如下：</p>

<pre><code>@property (readonly, nonatomic, assign) AFSSLPinningMode SSLPinningMode;
@property (nonatomic, assign) BOOL allowInvalidCertificates;
@property (nonatomic, assign) BOOL validatesDomainName;
</code></pre>

<p>SSLPingMode是最重要的属性，它标明了AFSecurityPolicy是以何种方式来验证。它是一个枚举类型，这个枚举类型有三个值，分别是AFSSLPinningModeNone、AFSSLPinningModePublicKey、AFSSLPinningModeCertificate。其中，AFSSLPinningModeNone代表了AFSecurityPolicy不做更严格的验证，只要是系统信任的证书就可以通过验证，不过，它受到allowInvalidCertificates和validatesDomainName的影响；AFSSLPinningModePublicKey是通过比较证书当中公钥(PublicKey)部分来进行验证，通过SecTrustCopyPublicKey方法获取本地证书和服务器证书，然后进行比较，如果有一个相同，则通过验证，此方式主要适用于自建证书搭建的HTTPS服务器和需要较高安全要求的验证；AFSSLPinningModeCertificate则是直接将本地的证书设置为信任的根证书，然后来进行判断，并且比较本地证书的内容和服务器证书内容是否相同，来进行二次判断，此方式适用于较高安全要求的验证。   <br/>
allowInvalidCertificates属性代表是否允许不信任的证书通过验证，默认为NO   <br/>
validatesDomainName属性代表是否验证主机名，默认为YES</p>

<p>接下来，我们说下验证流程。验证流程主要放在AFSecurityPolicy的- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain方法当中。</p>

<pre><code>- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust
                  forDomain:(NSString *)domain
{
    //当使用自建证书验证域名时，需要使用AFSSLPinningModePublicKey或者AFSSLPinningModeCertificate
    if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) {
        NSLog(@"In order to validate a domain name for self signed certificates, you MUST use pinning.");
        return NO;
    }

    NSMutableArray *policies = [NSMutableArray array];
    //需要验证域名时，需要添加一个验证域名的策略
    if (self.validatesDomainName) {
        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];
    } else {
        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];
    }

    //设置验证的策略，可以是多个
    SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);

    //SSLPinningMode为AFSSLPinningModeNone时，allowInvalidCertificates为YES，则代表服务器任何证书都能验证通过；如果它为NO，则需要判断此服务器证书是否是系统信任的证书
    if (self.SSLPinningMode == AFSSLPinningModeNone) {
        if (self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust)){
            return YES;
        } else {
            return NO;
        }
    } else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) {
        return NO;
    }

    //获取服务器证书的内容
    NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);
    switch (self.SSLPinningMode) {
        case AFSSLPinningModeNone:
        default:
            return NO;
        case AFSSLPinningModeCertificate: {
            //AFSSLPinningModeCertificate是直接将本地的证书设置为信任的根证书，然后来进行判断，并且比较本地证书的内容和服务器证书内容是否相同，如果有一个相同则返回YES

            NSMutableArray *pinnedCertificates = [NSMutableArray array];
            for (NSData *certificateData in self.pinnedCertificates) {
                [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];
            }
            //设置本地的证书为根证书
            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);

            //通过本地的证书来判断服务器证书是否可信，不可信，则验证不通过
            if (!AFServerTrustIsValid(serverTrust)) {
                return NO;
            }

            //判断本地证书和服务器证书的内容是否相同
            NSUInteger trustedCertificateCount = 0;
            for (NSData *trustChainCertificate in serverCertificates) {
                if ([self.pinnedCertificates containsObject:trustChainCertificate]) {
                    trustedCertificateCount++;
                }
            }
            return trustedCertificateCount &gt; 0;
        }
        case AFSSLPinningModePublicKey: {
            //AFSSLPinningModePublicKey是通过比较证书当中公钥(PublicKey)部分来进行验证，通过SecTrustCopyPublicKey方法获取本地证书和服务器证书，然后进行比较，如果有一个相同，则通过验证

            NSUInteger trustedPublicKeyCount = 0;
            NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);

            //判断服务器证书的公钥与本地的证书公钥是否相同，相同则客户端认证通过
            for (id trustChainPublicKey in publicKeys) {
                for (id pinnedPublicKey in self.pinnedPublicKeys) {
                    if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) {
                        trustedPublicKeyCount += 1;
                    }
                }
            }
            return trustedPublicKeyCount &gt; 0;
        }
    }

    return NO;
}
</code></pre>

<p>说了验证流程，我们最后来看看AFNetworking怎么使用，代码如下：</p>

<pre><code> _httpClient = [[BGAFHTTPClient alloc] initWithBaseURL:[NSURL URLWithString:baseURL]];
 AFSecurityPolicy *policy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];
 //是否允许CA不信任的证书通过
policy.allowInvalidCertificates = YES;
//是否验证主机名
policy.validatesDomainName = YES;
_httpClient.securityPolicy = policy;  
</code></pre>

<p> 这里我就没有建立Demo了，如果要看的话，可以看看我写的一个框架<a href="https://github.com/liuchungui/BGNetwork">BGNetwork</a>，里面的Demo对ATS进行了适配，AFNetworking的使用放在BGNetworkConnector类里面的<code>- (instancetype)initWithBaseURL:(NSString *)baseURL delegate:(id&lt;BGNetworkConnectorDelegate&gt;)delegate</code>初始化方法中。</p>

<h3>五、适配ATS</h3>

<p>前面的内容讲述都是满足ATS特性的情况，但若是服务器是自建证书搭建的，或者TLS版本是1.0的话，服务器又不能轻易改动，那么我们客户端如何适配呢？
不急，我们可以在工程中的Info.plist文件当中进行设置，主要参照下图：
<img src="http://ww3.sinaimg.cn/large/91c6e389jw1ewvshzy5ilj21340m641y.jpg" alt="图片" />
适配过程中的一些总结： <br/>
1、如果是自建证书，没有经过权威机构认证的证书，那么需要将NSAllowsArbitraryLoads设置为YES才能通过。NSAllowsArbitraryLoads为YES，以前的HTTP请求也能通过。       <br/>
2、如果是认证过的证书，那么可以通过<code>nscurl --ats-diagnostics --verbose https://casetree.cn</code>这样的命令来查看服务器支持的ATS Dictionary，然后进行对应的设置。</p>

<p>适配的部分，也可以参照<a href="https://github.com/ChenYilong/iOS9AdaptationTips#1-demo1_ios9%E7%BD%91%E7%BB%9C%E9%80%82%E9%85%8D_ats%E6%94%B9%E7%94%A8%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84https">Demo1_iOS9网络适配_ATS：改用更安全的HTTPS</a></p>

<h3>总结</h3>

<p>回顾前面的内容，总结一下，主要讲了一下几点内容  <br/>
1. ATS需要满足的条件  <br/>
2. 如何建立证书，搭建HTTPS服务器    <br/>
3. 使用nscurl命令来检测HTTPS服务器是否满足ATS特性  <br/>
4. 客户端的适配，讲述了NSURLSession和AFNetworking的使用  <br/>
5. 讲述了如果建立的服务器不满足ATS的条件时，我们如何适配</p>

<h3>参考</h3>

<p><a href="https://developer.apple.com/library/mac/technotes/App-Transport-Security-Technote/">App Transport Security Technote</a>   <br/>
<a href="https://developer.apple.com/library/ios/technotes/tn2232/_index.html#//apple_ref/doc/uid/DTS40012884-CH1-SECCUSTOMIZEAPIS">HTTPS Server Trust Evaluation</a>   <br/>
<a href="http://www.cocoachina.com/ios/20150810/12947.html">打造安全的App！iOS安全系列之 HTTPS</a>   <br/>
<a href="http://www.cocoachina.com/ios/20140916/9632.html">AFNetworking源码解析&lt;三></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AutoLayout使用代码写约束]]></title>
    <link href="http://liuchungui.github.io/blog/2015/09/20/autolayoutshi-yong-dai-ma-xie-yue-shu/"/>
    <updated>2015-09-20T23:20:56+08:00</updated>
    <id>http://liuchungui.github.io/blog/2015/09/20/autolayoutshi-yong-dai-ma-xie-yue-shu</id>
    <content type="html"><![CDATA[<h3>一、约束是什么？</h3>

<p>  约束是视图与视图之间一些属性关系。</p>

<!-- more -->


<p>  我们先来了解一下下面的内容：</p>

<p>  <strong>视图属性</strong>：视图属性(attribute)有<code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code>, <code>leading</code>, <code>trailing</code>, <code>width</code>, <code>height</code>, <code>centerX</code>, <code>centerY</code> 和 <code>baseline</code>。(注：iOS8加上了<code>Margin</code>，所以实际上从iOS8开始不止这些)</p>

<p>约束属性：每一个约束(Constraint)拥有的属性(Property)有：</p>

<ul>
<li> <strong>Constant value</strong>: 偏移量</li>
<li> <strong>Relation</strong>: 属性之间的关系，和关系表达式对应，例如>(大于),=(等于),>=(大于等于)</li>
<li> <strong>Priority level</strong>: 优先级，优先级越高，越会满足此约束。</li>
</ul>


<p>一个普通约束表达式: <code>view1.attribute = view2.attribute + ConstantValue</code></p>

<p>例子：当你定义一个button的位置时，你可能会有这么一个要求："按钮的左边距离父视图的左边20像素"。其实这句话用约束表达就是<code>button.left = (superView.left + 20)</code>。</p>

<h3>二、VFL(Visual Format Language)</h3>

<h5>1、语法</h5>

<p>下面这是一些常用的VFL语法示例，如果想要知道更详细的语法规则，请查看<a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html">Auto Layout Guide</a></p>

<table style="text-align:center;" bgcolor="#FFFFFF"> 
   <tbody>
    <tr> 
     <td>语法示例</td> 
     <td>效果图片</td> 
     <td>解释</td> 
    </tr> 
   </tbody>
   <tbody> 
    <tr> 
     <td>[button]-[textField]</td> 
     <td><img src="http://ww4.sinaimg.cn/large/91c6e389jw1ew8up8p9omj205z00odfm.jpg" /></td> 
     <td>标准空间距离为8像素</td> 
    </tr> 
    <tr> 
     <td>[button(&gt;=50)]</td> 
     <td><img src="http://ww2.sinaimg.cn/large/91c6e389jw1ew8ur9pn6nj2020015q2q.jpg" /></td> 
     <td>宽度约束</td> 
    </tr> 
    <tr> 
     <td>|-50-[purpleBox]-50-|</td> 
     <td><img src="http://ww4.sinaimg.cn/large/91c6e389jw1ew8uro1kggj204800wq2r.jpg" /></td> 
     <td>设置与父视图的关系，'|'代表父视图</td> 
    </tr> 
    <tr> 
     <td>V:[topField]-10-[bottomField]</td> 
     <td><img src="http://ww1.sinaimg.cn/large/91c6e389jw1ew8us3r78nj202o01ia9t.jpg" /></td> 
     <td>垂直方向的布局，'V'代表垂直方向，'H'代表水平方向</td> 
    </tr> 
    <tr> 
     <td>[maroonView][blueView]</td> 
     <td><img src="http://ww1.sinaimg.cn/large/91c6e389jw1ew8usnshqsj202r00k0b9.jpg" /></td> 
     <td>Flush Views</td> 
    </tr> 
    <tr> 
     <td>[button(100@20)]</td> 
     <td><img src="http://ww1.sinaimg.cn/large/91c6e389jw1ew8usxcz1lj202u014t8i.jpg" /></td> 
     <td>设置优先级，@后面就是此约束的优先级</td> 
    </tr> 
    <tr> 
     <td>[button1(==button2)]</td> 
     <td><img src="http://ww3.sinaimg.cn/large/91c6e389jw1ew8ut6n9abj205e015jr9.jpg" /></td> 
     <td>等宽设置</td> 
    </tr> 
    <tr> 
     <td>[flexibleButton(&gt;=70,&lt;=100)]</td> 
     <td><img src="http://ww4.sinaimg.cn/large/91c6e389jw1ew8uteqiv8j202t01m744.jpg" /></td> 
     <td>多个谓语来确定尺寸</td> 
    </tr> 
   </tbody> 
</table>


<p></p>

<h5>2、VFL使用</h5>

<p>我们现在需要做这么一个UI需求：页面中有两个元素一张图片和一个文本。图片距左右两边和顶部10像素，而距底部100像素；文本距图片30像素。这个用代码如何实现？请看下面代码：</p>

<pre><code class="objc">UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"dog.jpg"]];
imageView.contentMode = UIViewContentModeScaleAspectFit;
//注意：代码约束需要设置视图的translatesAutoresizingMaskIntoConstraints属性为NO
imageView.translatesAutoresizingMaskIntoConstraints = NO;
[self.view addSubview:imageView];
self.imageView = imageView;

UILabel *label = [[UILabel alloc] initWithFrame:CGRectZero];
label.textColor = [UIColor darkGrayColor];
label.text = @"This is a lovely dog";
label.translatesAutoresizingMaskIntoConstraints = NO;
[self.view addSubview:label];

NSDictionary *viewsDictionary = NSDictionaryOfVariableBindings(imageView, label);

//设置图片的水平方向距父视图左右两边都为10
NSArray *constraintArr1 = [NSLayoutConstraint constraintsWithVisualFormat:@"H:|-10-[imageView]-10-|" options:0 metrics:nil views:viewsDictionary];
[self.view addConstraints:constraintArr1];

//设置图片垂直方向距父视图顶部10，底部100
NSArray *constraintArr2 = [NSLayoutConstraint constraintsWithVisualFormat:@"V:|-10-[imageView]-100-|" options:0 metrics:nil views:viewsDictionary];
[self.view addConstraints:constraintArr2];

//设置label的约束
NSArray *constraintArr3 = [NSLayoutConstraint constraintsWithVisualFormat:@"V:[imageView]-30-[label]" options:0 metrics:nil views:viewsDictionary];
[self.view addConstraints:constraintArr3];
</code></pre>

<p>如下是运行的效果图：</p>

<p><img src="http://ww4.sinaimg.cn/large/91c6e389jw1ew8yjnu80jj20yi1pcwj4.jpg" width=310 height=552 /></p>

<p>   到这里，我们已经使用VFL实现了需求。</p>

<p>   假如有一天，我们的产品经理觉得这个效果不好看，需要改一改，然后UI设计师重新出了一套效果图。上面的页面已经修改成：图片距左右两边和顶部10像素，而图片宽与高比例为5:7；描述文本处于水平居中位置，并且处于图片的下方与屏幕上方居中位置。</p>

<p>   此时，我们用代码如何实现？</p>

<p>   查看VFL语法，明显图片宽与高比例为5:7这个需求没有直接对应的语法，实现起来有点复杂。这时，我们可以使用苹果为我们封装的另外一个创建约束的方法<code>constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:</code>，就可以轻易实现我们的需求。如下，就是实现代码：</p>

<pre><code class="objc">
UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"dog.jpg"]];
imageView.contentMode = UIViewContentModeScaleAspectFit;
//注意：代码约束需要设置视图的translatesAutoresizingMaskIntoConstraints属性为NO
imageView.translatesAutoresizingMaskIntoConstraints = NO;
[self.view addSubview:imageView];
self.imageView = imageView;

UILabel *label = [[UILabel alloc] initWithFrame:CGRectZero];
label.textColor = [UIColor darkGrayColor];
label.text = @"This is a lovely dog";
label.translatesAutoresizingMaskIntoConstraints = NO;
[self.view addSubview:label];

NSDictionary *viewsDictionary = NSDictionaryOfVariableBindings(imageView, label);

//设置图片的水平方向距父视图左右两边都为10像素
NSArray *constraintArr1 = [NSLayoutConstraint constraintsWithVisualFormat:@"H:|-10-[imageView]-10-|" options:0 metrics:nil views:viewsDictionary];
[self.view addConstraints:constraintArr1];

/*
//设置图片垂直方向距父视图顶部10像素，底部100像素
NSArray *constraintArr2 = [NSLayoutConstraint constraintsWithVisualFormat:@"V:|-10-[imageView]-100-|" options:0 metrics:nil views:viewsDictionary];
[self.view addConstraints:constraintArr2];

//设置label的约束
NSArray *constraintArr3 = [NSLayoutConstraint constraintsWithVisualFormat:@"V:[imageView]-30-[label]" options:0 metrics:nil views:viewsDictionary];
[self.view addConstraints:constraintArr3];
    */

//设置图片的宽与高的比例为5:7
NSLayoutConstraint *constraint1 = [NSLayoutConstraint constraintWithItem:imageView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:imageView attribute:NSLayoutAttributeWidth multiplier:1.4 constant:0];
[self.view addConstraint:constraint1];

//设置图片距顶部10像素，描述文字处于图片与屏幕底部中间
NSArray *constraintArr3 = [NSLayoutConstraint constraintsWithVisualFormat:@"V:|-10-[imageView]-[label]-|" options:0 metrics:nil views:viewsDictionary];
[self.view addConstraints:constraintArr3];

//描述文本水平居中
NSLayoutConstraint *constraint2 = [NSLayoutConstraint constraintWithItem:label attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];
[self.view addConstraint:constraint2];
</code></pre>

<p>运行效果如下：</p>

<p><img src="http://ww4.sinaimg.cn/large/91c6e389jw1ew905ecso1j20yi1pc78y.jpg" width=310 height=552 /></p>

<p><code>constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:</code>方法主要是为了创建视图约束属性之间的关系，而这个方法的精髓主要是这么一个表达式：<strong>view1.attribute = view2.attribute * multiplier + constant</strong>。这里与我们前面讲过的表达式类似，只是多了一个multiplier的系数。</p>

<h3>三、Masnory写约束</h3>

<p><a href="https://github.com/SnapKit/Masonry">Masonry</a>是一个轻量级的布局框架，拥有自己的描述语法，采用更优雅的链式语法封装自动布局，简洁明了 并具有高可读性。</p>

<p>上面的需求，我使用Masnory实现起来，代码简洁了很多，而且基本上不怎么需要学就能通过Masnory实现上面的需求，代码如下：</p>

<pre><code class="objc">//注意：代码约束需要设置视图的translatesAutoresizingMaskIntoConstraints属性为NO
UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"dog.jpg"]];
imageView.contentMode = UIViewContentModeScaleAspectFit;
imageView.translatesAutoresizingMaskIntoConstraints = NO;
[self.view addSubview:imageView];

UILabel *label = [[UILabel alloc] initWithFrame:CGRectZero];
label.textColor = [UIColor darkGrayColor];
label.text = @"This is a lovely dog";
label.translatesAutoresizingMaskIntoConstraints = NO;
[self.view addSubview:label];

//设置图片的水平方向距父视图左右两边都为10像素，图片的宽与高的比例为5:7
[imageView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.equalTo(self.view.mas_left).with.offset(10);
    make.right.equalTo(self.view.mas_right).with.offset(-10);
    make.top.equalTo(self.view.mas_top).with.offset(10);
    make.height.equalTo(imageView.mas_width).with.multipliedBy(1.4);
}];

//文字描述水平居中，并且处于图片与屏幕底部中间
[label mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.equalTo(self.view.mas_centerX);
    make.top.equalTo(imageView.mas_bottom);
    make.bottom.equalTo(self.view.mas_bottom);
}];
</code></pre>

<p>  效果如下：</p>

<p>  <img src="http://ww4.sinaimg.cn/large/91c6e389jw1ew905ecso1j20yi1pc78y.jpg" width=310 height=552 /></p>

<p>  示例代码已经放到github上了，<a href="https://github.com/liuchungui/VFLDemo.git">github代码示例</a></p>

<h3>四、使用AutoLayout时，如何添加动画？</h3>

<p> 使用VFL时，动画改变尺寸或位置时，很简单只需要将对应的约束保存成全局变量，然后改变约束当中的属性就行了。</p>

<p> 使用Autolayout动画改变尺寸、位置的官方模板如下：</p>

<pre><code class="objc">[containerView layoutIfNeeded]; // Ensures that all pending layout operations have been completed[UIView animateWithDuration:1.0 animations:^{    // Make all constraint changes here[containerView layoutIfNeeded]; // Forces the layout of the subtree animation block and then captures all of the frame changes}];
</code></pre>

<p>那如果使用的是Masnory框架，怎么添加动画？</p>

<p>我这里有个Demo，请看代码：</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    //创建displayView
    UIView *displayView = [[UIView alloc] init];
    displayView.backgroundColor = [UIColor purpleColor];
    [self.view addSubview:displayView];
    self.displayView = displayView;

    UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];
    [button setTitle:@"点击" forState:UIControlStateNormal];
    [button setTitleColor:[UIColor darkGrayColor] forState:UIControlStateHighlighted];
    [button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal];
    [button addTarget:self action:@selector(buttonAction:) forControlEvents:UIControlEventTouchUpInside];
    [self.view addSubview:button];

    //添加约束
    [displayView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.top.equalTo(self.view.mas_top).offset(100);
        make.size.mas_equalTo(CGSizeMake(50, 50));
        make.centerX.equalTo(self.view.mas_centerX);
    }];

    [button mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.equalTo(self.view.mas_centerX);
        make.size.mas_equalTo(CGSizeMake(200, 50));
        make.bottom.mas_equalTo(self.view.mas_bottom).offset(-50);
    }];
    // Do any additional setup after loading the view, typically from a nib.
} 


- (void)buttonAction:(UIButton *)butt    on{
    //动    画改变
    [self.view layoutIfNeeded];
    [UIView animateWithDuration:1.0 animations:^{
        [self.displayView mas_updateConstraints:^(MASConstraintMaker *make) {
            make.size.mas_equalTo(CGSizeMake(300, 300));
            }];
        [self.view layoutIfNeeded];
    }];
}
</code></pre>

<p>示例代码已经放到github上了，<a href="https://github.com/liuchungui/AnimationForAutoLayoutDemo.git">github代码示例</a></p>

<h3>五、什么时候使用代码写约束？</h3>

<p>  使用Xib写约束，可以很直观、快捷的搭建界面，让我们的开发速度提升很快。但，Xib开发有时候不是很灵活，这个时候我们就得考虑使用代码来实现约束。</p>

<p>  以下几种情况，我觉得使用代码写约束比较适合：</p>

<ul>
<li>运行时改变视图尺寸、位置的时候，应该使用代码写约束</li>
<li>封装一个控件时，使其能够有足够的灵活性，应该使用代码写约束</li>
<li>添加动画的时候，使用代码写约束。</li>
<li>一些复杂的UI，使用IB很难实现的场景，使用代码写约束</li>
</ul>


<h3>六、总结</h3>

<p>这篇文章主要讲了下面一些东西</p>

<ul>
<li>约束是什么</li>
<li>VFL相关语法</li>
<li>VFL的使用</li>
<li>Masnory框架的使用</li>
<li>使用Autolayout时，添加动画</li>
<li>哪些场景下使用代码来写约束</li>
</ul>

]]></content>
  </entry>
  
</feed>
